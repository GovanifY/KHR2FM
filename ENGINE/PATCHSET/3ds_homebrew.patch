From 40ef882d22922ca320df3c34412872c0944004a3 Mon Sep 17 00:00:00 2001
From: Thomas Edvalson <machin3@gmail.com>
Date: Mon, 3 Oct 2016 16:26:38 -0400
Subject: [PATCH 1/4] Add 3ds into build system

---
 .build.sh                                  |   13 +
 .travis.yml                                |   71 +-
 core/variant_parser.cpp                    |    8 +-
 drivers/3ds/SCsub                          |    7 +
 drivers/3ds/citro3d/SCsub                  |    5 +
 drivers/3ds/citro3d/rasterizer_citro3d.cpp | 1987 ++++++++++++++++++++++++++++
 drivers/3ds/citro3d/rasterizer_citro3d.h   |  812 ++++++++++++
 drivers/SCsub                              |    1 +
 platform/3ds/SCsub                         |    8 +
 platform/3ds/context_gl_x11.cpp            |  242 ++++
 platform/3ds/context_gl_x11.h              |   80 ++
 platform/3ds/detect.py                     |  188 +++
 platform/3ds/export/export.cpp             |   50 +
 platform/3ds/export/export.h               |   29 +
 platform/3ds/godot_3ds.cpp                 |   56 +
 platform/3ds/key_mapping_x11.cpp           | 1813 +++++++++++++++++++++++++
 platform/3ds/key_mapping_x11.h             |   55 +
 platform/3ds/logo.png                      |  Bin 0 -> 1406 bytes
 platform/3ds/memory.h                      |    1 +
 platform/3ds/os_3ds.cpp                    |  357 +++++
 platform/3ds/os_3ds.h                      |  305 +++++
 platform/3ds/platform_config.h             |   39 +
 22 files changed, 6057 insertions(+), 70 deletions(-)
 create mode 100644 .build.sh
 create mode 100644 drivers/3ds/SCsub
 create mode 100644 drivers/3ds/citro3d/SCsub
 create mode 100644 drivers/3ds/citro3d/rasterizer_citro3d.cpp
 create mode 100644 drivers/3ds/citro3d/rasterizer_citro3d.h
 create mode 100644 platform/3ds/SCsub
 create mode 100644 platform/3ds/context_gl_x11.cpp
 create mode 100644 platform/3ds/context_gl_x11.h
 create mode 100644 platform/3ds/detect.py
 create mode 100644 platform/3ds/export/export.cpp
 create mode 100644 platform/3ds/export/export.h
 create mode 100644 platform/3ds/godot_3ds.cpp
 create mode 100644 platform/3ds/key_mapping_x11.cpp
 create mode 100644 platform/3ds/key_mapping_x11.h
 create mode 100644 platform/3ds/logo.png
 create mode 100644 platform/3ds/memory.h
 create mode 100644 platform/3ds/os_3ds.cpp
 create mode 100644 platform/3ds/os_3ds.h
 create mode 100644 platform/3ds/platform_config.h

diff --git a/.build.sh b/.build.sh
new file mode 100644
index 0000000..dcc8c9f
--- /dev/null
+++ b/.build.sh
@@ -0,0 +1,13 @@
+#!/bin/sh
+set -ex
+
+export PATH=$DEVKITARM/bin:$PATH
+
+apt-get update
+apt-get -y install scons
+
+if [ "$1" = "x11" ] ; then
+	apt-get -y install libxcursor-dev libasound2-dev libssl-dev libxinerama-dev libxrandr-dev
+fi
+
+scons platform=$1 target=release -j 4
diff --git a/drivers/3ds/SCsub b/drivers/3ds/SCsub
new file mode 100644
index 0000000..db562e0
--- /dev/null
+++ b/drivers/3ds/SCsub
@@ -0,0 +1,7 @@
+Import('env')
+
+env.add_source_files(env.drivers_sources,"*.cpp")
+
+SConscript("citro3d/SCsub")
+
+Export('env')
diff --git a/drivers/3ds/citro3d/SCsub b/drivers/3ds/citro3d/SCsub
new file mode 100644
index 0000000..1ffb312
--- /dev/null
+++ b/drivers/3ds/citro3d/SCsub
@@ -0,0 +1,5 @@
+Import('env')
+
+env.add_source_files(env.drivers_sources,"*.cpp")
+
+#SConscript("shaders/SCsub")
diff --git a/drivers/3ds/citro3d/rasterizer_citro3d.cpp b/drivers/3ds/citro3d/rasterizer_citro3d.cpp
new file mode 100644
index 0000000..bbf164d
--- /dev/null
+++ b/drivers/3ds/citro3d/rasterizer_citro3d.cpp
@@ -0,0 +1,1987 @@
+/*************************************************************************/
+/*  rasterizer_citro3d.cpp                                                 */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#ifdef _3DS
+
+#include "rasterizer_citro3d.h"
+
+/* TEXTURE API */
+
+
+RID RasterizerCitro3d::texture_create() {
+
+	Texture *texture = memnew(Texture);
+	ERR_FAIL_COND_V(!texture,RID());
+	return texture_owner.make_rid( texture );
+
+}
+
+void RasterizerCitro3d::texture_allocate(RID p_texture,int p_width, int p_height,Image::Format p_format,uint32_t p_flags) {
+
+
+	Texture *texture = texture_owner.get( p_texture );
+	ERR_FAIL_COND(!texture);
+	texture->tex.width=p_width;
+	texture->tex.height=p_height;
+	texture->format=p_format;
+	texture->flags=p_flags;
+}
+
+void RasterizerCitro3d::texture_set_data(RID p_texture,const Image& p_image,VS::CubeMapSide p_cube_side) {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND(!texture);
+	ERR_FAIL_COND(texture->format != p_image.get_format() );
+
+	texture->image[p_cube_side]=p_image;
+
+}
+
+Image RasterizerCitro3d::texture_get_data(RID p_texture,VS::CubeMapSide p_cube_side) const {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND_V(!texture,Image());
+
+	return texture->image[p_cube_side];
+}
+
+void RasterizerCitro3d::texture_set_flags(RID p_texture,uint32_t p_flags) {
+
+	Texture *texture = texture_owner.get( p_texture );
+	ERR_FAIL_COND(!texture);
+	uint32_t cube = texture->flags & VS::TEXTURE_FLAG_CUBEMAP;
+	texture->flags=p_flags|cube; // can't remove a cube from being a cube
+
+}
+uint32_t RasterizerCitro3d::texture_get_flags(RID p_texture) const {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND_V(!texture,0);
+
+	return texture->flags;
+
+}
+Image::Format RasterizerCitro3d::texture_get_format(RID p_texture) const {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND_V(!texture,Image::FORMAT_GRAYSCALE);
+
+	return texture->format;
+}
+uint32_t RasterizerCitro3d::texture_get_width(RID p_texture) const {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND_V(!texture,0);
+
+	return texture->tex.width;
+}
+uint32_t RasterizerCitro3d::texture_get_height(RID p_texture) const {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND_V(!texture,0);
+
+	return texture->tex.height;
+}
+
+bool RasterizerCitro3d::texture_has_alpha(RID p_texture) const {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND_V(!texture,0);
+
+	return false;
+
+}
+
+void RasterizerCitro3d::texture_set_size_override(RID p_texture,int p_width, int p_height) {
+
+	Texture * texture = texture_owner.get(p_texture);
+
+	ERR_FAIL_COND(!texture);
+
+	ERR_FAIL_COND(p_width<=0 || p_width>1024);
+	ERR_FAIL_COND(p_height<=0 || p_height>1024);
+	//real texture size is in alloc width and height
+//	texture->width=p_width;
+//	texture->height=p_height;
+
+}
+
+void RasterizerCitro3d::texture_set_reload_hook(RID p_texture,ObjectID p_owner,const StringName& p_function) const {
+
+
+}
+
+/* SHADER API */
+
+/* SHADER API */
+
+RID RasterizerCitro3d::shader_create(VS::ShaderMode p_mode) {
+
+	Shader *shader = memnew( Shader );
+	shader->mode=p_mode;
+	shader->fragment_line=0;
+	shader->vertex_line=0;
+	shader->light_line=0;
+	RID rid = shader_owner.make_rid(shader);
+
+	return rid;
+
+}
+
+
+
+void RasterizerCitro3d::shader_set_mode(RID p_shader,VS::ShaderMode p_mode) {
+
+	ERR_FAIL_INDEX(p_mode,3);
+	Shader *shader=shader_owner.get(p_shader);
+	ERR_FAIL_COND(!shader);
+	shader->mode=p_mode;
+
+}
+VS::ShaderMode RasterizerCitro3d::shader_get_mode(RID p_shader) const {
+
+	Shader *shader=shader_owner.get(p_shader);
+	ERR_FAIL_COND_V(!shader,VS::SHADER_MATERIAL);
+	return shader->mode;
+}
+
+void RasterizerCitro3d::shader_set_code(RID p_shader, const String& p_vertex, const String& p_fragment,const String& p_light,int p_vertex_ofs,int p_fragment_ofs,int p_light_ofs) {
+
+
+	Shader *shader=shader_owner.get(p_shader);
+	ERR_FAIL_COND(!shader);
+	shader->fragment_code=p_fragment;
+	shader->vertex_code=p_vertex;
+	shader->light_code=p_light;
+	shader->fragment_line=p_fragment_ofs;
+	shader->vertex_line=p_vertex_ofs;
+	shader->light_line=p_vertex_ofs;
+
+}
+
+
+String RasterizerCitro3d::shader_get_vertex_code(RID p_shader) const {
+
+	Shader *shader=shader_owner.get(p_shader);
+	ERR_FAIL_COND_V(!shader,String());
+	return shader->vertex_code;
+
+}
+
+String RasterizerCitro3d::shader_get_fragment_code(RID p_shader) const {
+
+	Shader *shader=shader_owner.get(p_shader);
+	ERR_FAIL_COND_V(!shader,String());
+	return shader->fragment_code;
+
+}
+
+String RasterizerCitro3d::shader_get_light_code(RID p_shader) const {
+
+	Shader *shader=shader_owner.get(p_shader);
+	ERR_FAIL_COND_V(!shader,String());
+	return shader->light_code;
+
+}
+
+void RasterizerCitro3d::shader_get_param_list(RID p_shader, List<PropertyInfo> *p_param_list) const {
+
+	Shader *shader=shader_owner.get(p_shader);
+	ERR_FAIL_COND(!shader);
+
+}
+
+
+void RasterizerCitro3d::shader_set_default_texture_param(RID p_shader, const StringName& p_name, RID p_texture) {
+
+}
+
+RID RasterizerCitro3d::shader_get_default_texture_param(RID p_shader, const StringName& p_name) const {
+
+	return RID();
+}
+
+Variant RasterizerCitro3d::shader_get_default_param(RID p_shader, const StringName& p_name) {
+
+	return Variant();
+}
+
+/* COMMON MATERIAL API */
+
+
+RID RasterizerCitro3d::material_create() {
+
+	return material_owner.make_rid( memnew( Material ) );
+}
+
+void RasterizerCitro3d::material_set_shader(RID p_material, RID p_shader) {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND(!material);
+	material->shader=p_shader;
+
+}
+
+RID RasterizerCitro3d::material_get_shader(RID p_material) const {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND_V(!material,RID());
+	return material->shader;
+}
+
+void RasterizerCitro3d::material_set_param(RID p_material, const StringName& p_param, const Variant& p_value) {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND(!material);
+
+	if (p_value.get_type()==Variant::NIL)
+		material->shader_params.erase(p_param);
+	else
+		material->shader_params[p_param]=p_value;
+}
+Variant RasterizerCitro3d::material_get_param(RID p_material, const StringName& p_param) const {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND_V(!material,Variant());
+
+	if (material->shader_params.has(p_param))
+		return material->shader_params[p_param];
+	else
+		return Variant();
+}
+
+
+void RasterizerCitro3d::material_set_flag(RID p_material, VS::MaterialFlag p_flag,bool p_enabled) {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND(!material);
+	ERR_FAIL_INDEX(p_flag,VS::MATERIAL_FLAG_MAX);
+	material->flags[p_flag]=p_enabled;
+
+}
+bool RasterizerCitro3d::material_get_flag(RID p_material,VS::MaterialFlag p_flag) const {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND_V(!material,false);
+	ERR_FAIL_INDEX_V(p_flag,VS::MATERIAL_FLAG_MAX,false);
+	return material->flags[p_flag];
+
+
+}
+
+void RasterizerCitro3d::material_set_depth_draw_mode(RID p_material, VS::MaterialDepthDrawMode p_mode) {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND(!material);
+	material->depth_draw_mode=p_mode;
+}
+
+VS::MaterialDepthDrawMode RasterizerCitro3d::material_get_depth_draw_mode(RID p_material) const{
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND_V(!material,VS::MATERIAL_DEPTH_DRAW_ALWAYS);
+	return material->depth_draw_mode;
+
+}
+
+
+void RasterizerCitro3d::material_set_blend_mode(RID p_material,VS::MaterialBlendMode p_mode) {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND(!material);
+	material->blend_mode=p_mode;
+
+}
+VS::MaterialBlendMode RasterizerCitro3d::material_get_blend_mode(RID p_material) const {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND_V(!material,VS::MATERIAL_BLEND_MODE_ADD);
+	return material->blend_mode;
+}
+
+void RasterizerCitro3d::material_set_line_width(RID p_material,float p_line_width) {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND(!material);
+	material->line_width=p_line_width;
+
+}
+float RasterizerCitro3d::material_get_line_width(RID p_material) const {
+
+	Material *material = material_owner.get(p_material);
+	ERR_FAIL_COND_V(!material,0);
+
+	return material->line_width;
+}
+
+/* MESH API */
+
+
+RID RasterizerCitro3d::mesh_create() {
+
+
+	return mesh_owner.make_rid( memnew( Mesh ) );
+}
+
+
+void RasterizerCitro3d::mesh_add_surface(RID p_mesh,VS::PrimitiveType p_primitive,const Array& p_arrays,const Array& p_blend_shapes,bool p_alpha_sort) {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND(!mesh);
+
+	ERR_FAIL_INDEX( p_primitive, VS::PRIMITIVE_MAX );
+	ERR_FAIL_COND(p_arrays.size()!=VS::ARRAY_MAX);
+
+	Surface s;
+
+
+	s.format=0;
+
+	for(int i=0;i<p_arrays.size();i++) {
+
+		if (p_arrays[i].get_type()==Variant::NIL)
+			continue;
+
+		s.format|=(1<<i);
+
+		if (i==VS::ARRAY_VERTEX) {
+
+			Vector3Array v = p_arrays[i];
+			int len = v.size();
+			ERR_FAIL_COND(len==0);
+			Vector3Array::Read r = v.read();
+
+
+			for(int i=0;i<len;i++) {
+
+				if (i==0)
+					s.aabb.pos=r[0];
+				else
+					s.aabb.expand_to(r[i]);
+			}
+
+		}
+	}
+
+	ERR_FAIL_COND((s.format&VS::ARRAY_FORMAT_VERTEX)==0); // mandatory
+
+	s.data=p_arrays;
+	s.morph_data=p_blend_shapes;
+	s.primitive=p_primitive;
+	s.alpha_sort=p_alpha_sort;
+	s.morph_target_count=mesh->morph_target_count;
+	s.morph_format=s.format;
+
+
+	Surface *surface = memnew( Surface );
+	*surface=s;
+
+	mesh->surfaces.push_back(surface);
+
+
+}
+
+
+
+void RasterizerCitro3d::mesh_add_custom_surface(RID p_mesh,const Variant& p_dat) {
+
+	ERR_EXPLAIN("Dummy Rasterizer does not support custom surfaces. Running on wrong platform?");
+	ERR_FAIL_V();
+}
+
+Array RasterizerCitro3d::mesh_get_surface_arrays(RID p_mesh,int p_surface) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,Array());
+	ERR_FAIL_INDEX_V(p_surface, mesh->surfaces.size(), Array() );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND_V( !surface, Array() );
+
+	return surface->data;
+
+
+}
+Array RasterizerCitro3d::mesh_get_surface_morph_arrays(RID p_mesh,int p_surface) const{
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,Array());
+	ERR_FAIL_INDEX_V(p_surface, mesh->surfaces.size(), Array() );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND_V( !surface, Array() );
+
+	return surface->morph_data;
+
+}
+
+
+void RasterizerCitro3d::mesh_set_morph_target_count(RID p_mesh,int p_amount) {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND(!mesh);
+	ERR_FAIL_COND( mesh->surfaces.size()!=0 );
+
+	mesh->morph_target_count=p_amount;
+
+}
+
+int RasterizerCitro3d::mesh_get_morph_target_count(RID p_mesh) const{
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,-1);
+
+	return mesh->morph_target_count;
+
+}
+
+void RasterizerCitro3d::mesh_set_morph_target_mode(RID p_mesh,VS::MorphTargetMode p_mode) {
+
+	ERR_FAIL_INDEX(p_mode,2);
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND(!mesh);
+
+	mesh->morph_target_mode=p_mode;
+
+}
+
+VS::MorphTargetMode RasterizerCitro3d::mesh_get_morph_target_mode(RID p_mesh) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,VS::MORPH_MODE_NORMALIZED);
+
+	return mesh->morph_target_mode;
+
+}
+
+
+
+void RasterizerCitro3d::mesh_surface_set_material(RID p_mesh, int p_surface, RID p_material,bool p_owned) {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND(!mesh);
+	ERR_FAIL_INDEX(p_surface, mesh->surfaces.size() );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND( !surface);
+
+	if (surface->material_owned && surface->material.is_valid())
+		free(surface->material);
+
+	surface->material_owned=p_owned;
+	surface->material=p_material;
+}
+
+RID RasterizerCitro3d::mesh_surface_get_material(RID p_mesh, int p_surface) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,RID());
+	ERR_FAIL_INDEX_V(p_surface, mesh->surfaces.size(), RID() );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND_V( !surface, RID() );
+
+	return surface->material;
+}
+
+int RasterizerCitro3d::mesh_surface_get_array_len(RID p_mesh, int p_surface) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,-1);
+	ERR_FAIL_INDEX_V(p_surface, mesh->surfaces.size(), -1 );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND_V( !surface, -1 );
+
+	Vector3Array arr = surface->data[VS::ARRAY_VERTEX];
+	return arr.size();
+
+}
+
+int RasterizerCitro3d::mesh_surface_get_array_index_len(RID p_mesh, int p_surface) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,-1);
+	ERR_FAIL_INDEX_V(p_surface, mesh->surfaces.size(), -1 );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND_V( !surface, -1 );
+
+	IntArray arr = surface->data[VS::ARRAY_INDEX];
+	return arr.size();
+
+}
+uint32_t RasterizerCitro3d::mesh_surface_get_format(RID p_mesh, int p_surface) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,0);
+	ERR_FAIL_INDEX_V(p_surface, mesh->surfaces.size(), 0 );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND_V( !surface, 0 );
+
+	return surface->format;
+}
+VS::PrimitiveType RasterizerCitro3d::mesh_surface_get_primitive_type(RID p_mesh, int p_surface) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,VS::PRIMITIVE_POINTS);
+	ERR_FAIL_INDEX_V(p_surface, mesh->surfaces.size(), VS::PRIMITIVE_POINTS );
+	Surface *surface = mesh->surfaces[p_surface];
+	ERR_FAIL_COND_V( !surface, VS::PRIMITIVE_POINTS );
+
+	return surface->primitive;
+}
+
+void RasterizerCitro3d::mesh_remove_surface(RID p_mesh,int p_index) {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND(!mesh);
+	ERR_FAIL_INDEX(p_index, mesh->surfaces.size() );
+	Surface *surface = mesh->surfaces[p_index];
+	ERR_FAIL_COND( !surface);
+
+	memdelete( mesh->surfaces[p_index] );
+	mesh->surfaces.remove(p_index);
+
+}
+int RasterizerCitro3d::mesh_get_surface_count(RID p_mesh) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,-1);
+
+	return mesh->surfaces.size();
+}
+
+AABB RasterizerCitro3d::mesh_get_aabb(RID p_mesh,RID p_skeleton) const {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,AABB());
+
+	AABB aabb;
+
+	for (int i=0;i<mesh->surfaces.size();i++) {
+
+		if (i==0)
+			aabb=mesh->surfaces[i]->aabb;
+		else
+			aabb.merge_with(mesh->surfaces[i]->aabb);
+	}
+
+	return aabb;
+}
+
+void RasterizerCitro3d::mesh_set_custom_aabb(RID p_mesh,const AABB& p_aabb) {
+
+	Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND(!mesh);
+
+	mesh->custom_aabb=p_aabb;
+}
+
+AABB RasterizerCitro3d::mesh_get_custom_aabb(RID p_mesh) const {
+
+	const Mesh *mesh = mesh_owner.get( p_mesh );
+	ERR_FAIL_COND_V(!mesh,AABB());
+
+	return mesh->custom_aabb;
+
+}
+
+/* MULTIMESH API */
+
+RID RasterizerCitro3d::multimesh_create() {
+
+	return multimesh_owner.make_rid( memnew( MultiMesh ));
+}
+
+void RasterizerCitro3d::multimesh_set_instance_count(RID p_multimesh,int p_count) {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND(!multimesh);
+
+	multimesh->elements.clear(); // make sure to delete everything, so it "fails" in all implementations
+	multimesh->elements.resize(p_count);
+
+}
+int RasterizerCitro3d::multimesh_get_instance_count(RID p_multimesh) const {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND_V(!multimesh,-1);
+
+	return multimesh->elements.size();
+}
+
+void RasterizerCitro3d::multimesh_set_mesh(RID p_multimesh,RID p_mesh) {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND(!multimesh);
+
+	multimesh->mesh=p_mesh;
+
+}
+void RasterizerCitro3d::multimesh_set_aabb(RID p_multimesh,const AABB& p_aabb) {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND(!multimesh);
+	multimesh->aabb=p_aabb;
+}
+void RasterizerCitro3d::multimesh_instance_set_transform(RID p_multimesh,int p_index,const Transform& p_transform) {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND(!multimesh);
+	ERR_FAIL_INDEX(p_index,multimesh->elements.size());
+	multimesh->elements[p_index].xform=p_transform;
+
+}
+void RasterizerCitro3d::multimesh_instance_set_color(RID p_multimesh,int p_index,const Color& p_color) {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND(!multimesh)
+	ERR_FAIL_INDEX(p_index,multimesh->elements.size());
+	multimesh->elements[p_index].color=p_color;
+
+}
+
+RID RasterizerCitro3d::multimesh_get_mesh(RID p_multimesh) const {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND_V(!multimesh,RID());
+
+	return multimesh->mesh;
+}
+AABB RasterizerCitro3d::multimesh_get_aabb(RID p_multimesh) const {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND_V(!multimesh,AABB());
+
+	return multimesh->aabb;
+}
+
+Transform RasterizerCitro3d::multimesh_instance_get_transform(RID p_multimesh,int p_index) const {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND_V(!multimesh,Transform());
+
+	ERR_FAIL_INDEX_V(p_index,multimesh->elements.size(),Transform());
+
+	return multimesh->elements[p_index].xform;
+
+}
+Color RasterizerCitro3d::multimesh_instance_get_color(RID p_multimesh,int p_index) const {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND_V(!multimesh,Color());
+	ERR_FAIL_INDEX_V(p_index,multimesh->elements.size(),Color());
+
+	return multimesh->elements[p_index].color;
+}
+
+void RasterizerCitro3d::multimesh_set_visible_instances(RID p_multimesh,int p_visible) {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND(!multimesh);
+	multimesh->visible=p_visible;
+
+}
+
+int RasterizerCitro3d::multimesh_get_visible_instances(RID p_multimesh) const {
+
+	MultiMesh *multimesh = multimesh_owner.get(p_multimesh);
+	ERR_FAIL_COND_V(!multimesh,-1);
+	return multimesh->visible;
+
+}
+
+/* IMMEDIATE API */
+
+
+RID RasterizerCitro3d::immediate_create() {
+
+	Immediate *im = memnew( Immediate );
+	return immediate_owner.make_rid(im);
+
+}
+
+void RasterizerCitro3d::immediate_begin(RID p_immediate,VS::PrimitiveType p_rimitive,RID p_texture){
+
+
+}
+void RasterizerCitro3d::immediate_vertex(RID p_immediate,const Vector3& p_vertex){
+
+
+}
+void RasterizerCitro3d::immediate_normal(RID p_immediate,const Vector3& p_normal){
+
+
+}
+void RasterizerCitro3d::immediate_tangent(RID p_immediate,const Plane& p_tangent){
+
+
+}
+void RasterizerCitro3d::immediate_color(RID p_immediate,const Color& p_color){
+
+
+}
+void RasterizerCitro3d::immediate_uv(RID p_immediate,const Vector2& tex_uv){
+
+
+}
+void RasterizerCitro3d::immediate_uv2(RID p_immediate,const Vector2& tex_uv){
+
+
+}
+
+void RasterizerCitro3d::immediate_end(RID p_immediate){
+
+
+}
+void RasterizerCitro3d::immediate_clear(RID p_immediate) {
+
+
+}
+
+AABB RasterizerCitro3d::immediate_get_aabb(RID p_immediate) const {
+
+	return AABB(Vector3(-1,-1,-1),Vector3(2,2,2));
+}
+
+void RasterizerCitro3d::immediate_set_material(RID p_immediate,RID p_material) {
+
+	Immediate *im = immediate_owner.get(p_immediate);
+	ERR_FAIL_COND(!im);
+	im->material=p_material;
+
+}
+
+RID RasterizerCitro3d::immediate_get_material(RID p_immediate) const {
+
+	const Immediate *im = immediate_owner.get(p_immediate);
+	ERR_FAIL_COND_V(!im,RID());
+	return im->material;
+
+}
+
+/* PARTICLES API */
+
+RID RasterizerCitro3d::particles_create() {
+
+	Particles *particles = memnew( Particles );
+	ERR_FAIL_COND_V(!particles,RID());
+	return particles_owner.make_rid(particles);
+}
+
+void RasterizerCitro3d::particles_set_amount(RID p_particles, int p_amount) {
+
+	ERR_FAIL_COND(p_amount<1);
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.amount=p_amount;
+
+}
+
+int RasterizerCitro3d::particles_get_amount(RID p_particles) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,-1);
+	return particles->data.amount;
+
+}
+
+void RasterizerCitro3d::particles_set_emitting(RID p_particles, bool p_emitting) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.emitting=p_emitting;;
+
+}
+bool RasterizerCitro3d::particles_is_emitting(RID p_particles) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,false);
+	return particles->data.emitting;
+
+}
+
+void RasterizerCitro3d::particles_set_visibility_aabb(RID p_particles, const AABB& p_visibility) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.visibility_aabb=p_visibility;
+
+}
+
+void RasterizerCitro3d::particles_set_emission_half_extents(RID p_particles, const Vector3& p_half_extents) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+
+	particles->data.emission_half_extents=p_half_extents;
+}
+Vector3 RasterizerCitro3d::particles_get_emission_half_extents(RID p_particles) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,Vector3());
+
+	return particles->data.emission_half_extents;
+}
+
+void RasterizerCitro3d::particles_set_emission_base_velocity(RID p_particles, const Vector3& p_base_velocity) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+
+	particles->data.emission_base_velocity=p_base_velocity;
+}
+
+Vector3 RasterizerCitro3d::particles_get_emission_base_velocity(RID p_particles) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,Vector3());
+
+	return particles->data.emission_base_velocity;
+}
+
+
+void RasterizerCitro3d::particles_set_emission_points(RID p_particles, const DVector<Vector3>& p_points) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+
+	particles->data.emission_points=p_points;
+}
+
+DVector<Vector3> RasterizerCitro3d::particles_get_emission_points(RID p_particles) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,DVector<Vector3>());
+
+	return particles->data.emission_points;
+
+}
+
+void RasterizerCitro3d::particles_set_gravity_normal(RID p_particles, const Vector3& p_normal) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+
+	particles->data.gravity_normal=p_normal;
+
+}
+Vector3 RasterizerCitro3d::particles_get_gravity_normal(RID p_particles) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,Vector3());
+
+	return particles->data.gravity_normal;
+}
+
+
+AABB RasterizerCitro3d::particles_get_visibility_aabb(RID p_particles) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,AABB());
+	return particles->data.visibility_aabb;
+
+}
+
+void RasterizerCitro3d::particles_set_variable(RID p_particles, VS::ParticleVariable p_variable,float p_value) {
+
+	ERR_FAIL_INDEX(p_variable,VS::PARTICLE_VAR_MAX);
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.particle_vars[p_variable]=p_value;
+
+}
+float RasterizerCitro3d::particles_get_variable(RID p_particles, VS::ParticleVariable p_variable) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,-1);
+	return particles->data.particle_vars[p_variable];
+}
+
+void RasterizerCitro3d::particles_set_randomness(RID p_particles, VS::ParticleVariable p_variable,float p_randomness) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.particle_randomness[p_variable]=p_randomness;
+
+}
+float RasterizerCitro3d::particles_get_randomness(RID p_particles, VS::ParticleVariable p_variable) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,-1);
+	return particles->data.particle_randomness[p_variable];
+
+}
+
+void RasterizerCitro3d::particles_set_color_phases(RID p_particles, int p_phases) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	ERR_FAIL_COND( p_phases<0 || p_phases>VS::MAX_PARTICLE_COLOR_PHASES );
+	particles->data.color_phase_count=p_phases;
+
+}
+int RasterizerCitro3d::particles_get_color_phases(RID p_particles) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,-1);
+	return particles->data.color_phase_count;
+}
+
+
+void RasterizerCitro3d::particles_set_color_phase_pos(RID p_particles, int p_phase, float p_pos) {
+
+	ERR_FAIL_INDEX(p_phase, VS::MAX_PARTICLE_COLOR_PHASES);
+	if (p_pos<0.0)
+		p_pos=0.0;
+	if (p_pos>1.0)
+		p_pos=1.0;
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.color_phases[p_phase].pos=p_pos;
+
+}
+float RasterizerCitro3d::particles_get_color_phase_pos(RID p_particles, int p_phase) const {
+
+	ERR_FAIL_INDEX_V(p_phase, VS::MAX_PARTICLE_COLOR_PHASES, -1.0);
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,-1);
+	return particles->data.color_phases[p_phase].pos;
+
+}
+
+void RasterizerCitro3d::particles_set_color_phase_color(RID p_particles, int p_phase, const Color& p_color) {
+
+	ERR_FAIL_INDEX(p_phase, VS::MAX_PARTICLE_COLOR_PHASES);
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.color_phases[p_phase].color=p_color;
+
+	//update alpha
+	particles->has_alpha=false;
+	for(int i=0;i<VS::MAX_PARTICLE_COLOR_PHASES;i++) {
+		if (particles->data.color_phases[i].color.a<0.99)
+			particles->has_alpha=true;
+	}
+
+}
+
+Color RasterizerCitro3d::particles_get_color_phase_color(RID p_particles, int p_phase) const {
+
+	ERR_FAIL_INDEX_V(p_phase, VS::MAX_PARTICLE_COLOR_PHASES, Color());
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,Color());
+	return particles->data.color_phases[p_phase].color;
+
+}
+
+void RasterizerCitro3d::particles_set_attractors(RID p_particles, int p_attractors) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	ERR_FAIL_COND( p_attractors<0 || p_attractors>VisualServer::MAX_PARTICLE_ATTRACTORS );
+	particles->data.attractor_count=p_attractors;
+
+}
+int RasterizerCitro3d::particles_get_attractors(RID p_particles) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,-1);
+	return particles->data.attractor_count;
+}
+
+void RasterizerCitro3d::particles_set_attractor_pos(RID p_particles, int p_attractor, const Vector3& p_pos) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	ERR_FAIL_INDEX(p_attractor,particles->data.attractor_count);
+	particles->data.attractors[p_attractor].pos=p_pos;;
+}
+Vector3 RasterizerCitro3d::particles_get_attractor_pos(RID p_particles,int p_attractor) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,Vector3());
+	ERR_FAIL_INDEX_V(p_attractor,particles->data.attractor_count,Vector3());
+	return particles->data.attractors[p_attractor].pos;
+}
+
+void RasterizerCitro3d::particles_set_attractor_strength(RID p_particles, int p_attractor, float p_force) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	ERR_FAIL_INDEX(p_attractor,particles->data.attractor_count);
+	particles->data.attractors[p_attractor].force=p_force;
+}
+
+float RasterizerCitro3d::particles_get_attractor_strength(RID p_particles,int p_attractor) const {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,0);
+	ERR_FAIL_INDEX_V(p_attractor,particles->data.attractor_count,0);
+	return particles->data.attractors[p_attractor].force;
+}
+
+void RasterizerCitro3d::particles_set_material(RID p_particles, RID p_material,bool p_owned) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	if (particles->material_owned && particles->material.is_valid())
+		free(particles->material);
+
+	particles->material_owned=p_owned;
+
+	particles->material=p_material;
+
+}
+RID RasterizerCitro3d::particles_get_material(RID p_particles) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,RID());
+	return particles->material;
+
+}
+
+void RasterizerCitro3d::particles_set_use_local_coordinates(RID p_particles, bool p_enable) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.local_coordinates=p_enable;
+
+}
+
+bool RasterizerCitro3d::particles_is_using_local_coordinates(RID p_particles) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,false);
+	return particles->data.local_coordinates;
+}
+bool RasterizerCitro3d::particles_has_height_from_velocity(RID p_particles) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,false);
+	return particles->data.height_from_velocity;
+}
+
+void RasterizerCitro3d::particles_set_height_from_velocity(RID p_particles, bool p_enable) {
+
+	Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND(!particles);
+	particles->data.height_from_velocity=p_enable;
+
+}
+
+AABB RasterizerCitro3d::particles_get_aabb(RID p_particles) const {
+
+	const Particles* particles = particles_owner.get( p_particles );
+	ERR_FAIL_COND_V(!particles,AABB());
+	return particles->data.visibility_aabb;
+}
+
+/* SKELETON API */
+
+RID RasterizerCitro3d::skeleton_create() {
+
+	Skeleton *skeleton = memnew( Skeleton );
+	ERR_FAIL_COND_V(!skeleton,RID());
+	return skeleton_owner.make_rid( skeleton );
+}
+void RasterizerCitro3d::skeleton_resize(RID p_skeleton,int p_bones) {
+
+	Skeleton *skeleton = skeleton_owner.get( p_skeleton );
+	ERR_FAIL_COND(!skeleton);
+	if (p_bones == skeleton->bones.size()) {
+		return;
+	};
+
+	skeleton->bones.resize(p_bones);
+
+}
+int RasterizerCitro3d::skeleton_get_bone_count(RID p_skeleton) const {
+
+	Skeleton *skeleton = skeleton_owner.get( p_skeleton );
+	ERR_FAIL_COND_V(!skeleton, -1);
+	return skeleton->bones.size();
+}
+void RasterizerCitro3d::skeleton_bone_set_transform(RID p_skeleton,int p_bone, const Transform& p_transform) {
+
+	Skeleton *skeleton = skeleton_owner.get( p_skeleton );
+	ERR_FAIL_COND(!skeleton);
+	ERR_FAIL_INDEX( p_bone, skeleton->bones.size() );
+
+	skeleton->bones[p_bone] = p_transform;
+}
+
+Transform RasterizerCitro3d::skeleton_bone_get_transform(RID p_skeleton,int p_bone) {
+
+	Skeleton *skeleton = skeleton_owner.get( p_skeleton );
+	ERR_FAIL_COND_V(!skeleton, Transform());
+	ERR_FAIL_INDEX_V( p_bone, skeleton->bones.size(), Transform() );
+
+	// something
+	return skeleton->bones[p_bone];
+}
+
+
+/* LIGHT API */
+
+RID RasterizerCitro3d::light_create(VS::LightType p_type) {
+
+	Light *light = memnew( Light );
+	light->type=p_type;
+	return light_owner.make_rid(light);
+}
+
+VS::LightType RasterizerCitro3d::light_get_type(RID p_light) const {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND_V(!light,VS::LIGHT_OMNI);
+	return light->type;
+}
+
+void RasterizerCitro3d::light_set_color(RID p_light,VS::LightColor p_type, const Color& p_color) {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND(!light);
+	ERR_FAIL_INDEX( p_type, 3 );
+	light->colors[p_type]=p_color;
+}
+Color RasterizerCitro3d::light_get_color(RID p_light,VS::LightColor p_type) const {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND_V(!light, Color());
+	ERR_FAIL_INDEX_V( p_type, 3, Color() );
+	return light->colors[p_type];
+}
+
+void RasterizerCitro3d::light_set_shadow(RID p_light,bool p_enabled) {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND(!light);
+	light->shadow_enabled=p_enabled;
+}
+
+bool RasterizerCitro3d::light_has_shadow(RID p_light) const {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND_V(!light,false);
+	return light->shadow_enabled;
+}
+
+void RasterizerCitro3d::light_set_volumetric(RID p_light,bool p_enabled) {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND(!light);
+	light->volumetric_enabled=p_enabled;
+
+}
+bool RasterizerCitro3d::light_is_volumetric(RID p_light) const {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND_V(!light,false);
+	return light->volumetric_enabled;
+}
+
+void RasterizerCitro3d::light_set_projector(RID p_light,RID p_texture) {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND(!light);
+	light->projector=p_texture;
+}
+RID RasterizerCitro3d::light_get_projector(RID p_light) const {
+
+	Light *light = light_owner.get(p_light);
+	ERR_FAIL_COND_V(!light,RID());
+	return light->projector;
+}
+
+void RasterizerCitro3d::light_set_var(RID p_light, VS::LightParam p_var, float p_value) {
+
+	Light * light = light_owner.get( p_light );
+	ERR_FAIL_COND(!light);
+	ERR_FAIL_INDEX( p_var, VS::LIGHT_PARAM_MAX );
+
+	light->vars[p_var]=p_value;
+}
+float RasterizerCitro3d::light_get_var(RID p_light, VS::LightParam p_var) const {
+
+	Light * light = light_owner.get( p_light );
+	ERR_FAIL_COND_V(!light,0);
+
+	ERR_FAIL_INDEX_V( p_var, VS::LIGHT_PARAM_MAX,0 );
+
+	return light->vars[p_var];
+}
+
+void RasterizerCitro3d::light_set_operator(RID p_light,VS::LightOp p_op) {
+
+	Light * light = light_owner.get( p_light );
+	ERR_FAIL_COND(!light);
+
+
+};
+
+VS::LightOp RasterizerCitro3d::light_get_operator(RID p_light) const {
+
+	return VS::LightOp(0);
+};
+
+void RasterizerCitro3d::light_omni_set_shadow_mode(RID p_light,VS::LightOmniShadowMode p_mode) {
+
+
+}
+
+VS::LightOmniShadowMode RasterizerCitro3d::light_omni_get_shadow_mode(RID p_light) const{
+
+	return VS::LightOmniShadowMode(0);
+}
+
+void RasterizerCitro3d::light_directional_set_shadow_mode(RID p_light,VS::LightDirectionalShadowMode p_mode) {
+
+
+}
+
+VS::LightDirectionalShadowMode RasterizerCitro3d::light_directional_get_shadow_mode(RID p_light) const {
+
+	return VS::LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL;
+}
+
+void RasterizerCitro3d::light_directional_set_shadow_param(RID p_light,VS::LightDirectionalShadowParam p_param, float p_value) {
+
+
+}
+
+float RasterizerCitro3d::light_directional_get_shadow_param(RID p_light,VS::LightDirectionalShadowParam p_param) const {
+
+	return 0;
+}
+
+
+AABB RasterizerCitro3d::light_get_aabb(RID p_light) const {
+
+	Light *light = light_owner.get( p_light );
+	ERR_FAIL_COND_V(!light,AABB());
+
+	switch( light->type ) {
+
+		case VS::LIGHT_SPOT: {
+
+			float len=light->vars[VS::LIGHT_PARAM_RADIUS];
+			float size=Math::tan(Math::deg2rad(light->vars[VS::LIGHT_PARAM_SPOT_ANGLE]))*len;
+			return AABB( Vector3( -size,-size,-len ), Vector3( size*2, size*2, len ) );
+		} break;
+		case VS::LIGHT_OMNI: {
+
+			float r = light->vars[VS::LIGHT_PARAM_RADIUS];
+			return AABB( -Vector3(r,r,r), Vector3(r,r,r)*2 );
+		} break;
+		case VS::LIGHT_DIRECTIONAL: {
+
+			return AABB();
+		} break;
+		default: {}
+	}
+
+	ERR_FAIL_V( AABB() );
+}
+
+
+RID RasterizerCitro3d::light_instance_create(RID p_light) {
+
+	Light *light = light_owner.get( p_light );
+	ERR_FAIL_COND_V(!light, RID());
+
+	LightInstance *light_instance = memnew( LightInstance );
+
+	light_instance->light=p_light;
+	light_instance->base=light;
+
+
+	return light_instance_owner.make_rid( light_instance );
+}
+void RasterizerCitro3d::light_instance_set_transform(RID p_light_instance,const Transform& p_transform) {
+
+	LightInstance *lighti = light_instance_owner.get( p_light_instance );
+	ERR_FAIL_COND(!lighti);
+	lighti->transform=p_transform;
+
+}
+
+bool RasterizerCitro3d::light_instance_has_shadow(RID p_light_instance) const {
+
+	return false;
+
+}
+
+
+bool RasterizerCitro3d::light_instance_assign_shadow(RID p_light_instance) {
+
+	return false;
+
+}
+
+
+Rasterizer::ShadowType RasterizerCitro3d::light_instance_get_shadow_type(RID p_light_instance) const {
+
+	LightInstance *lighti = light_instance_owner.get( p_light_instance );
+	ERR_FAIL_COND_V(!lighti,Rasterizer::SHADOW_NONE);
+
+	switch(lighti->base->type) {
+
+		case VS::LIGHT_DIRECTIONAL: return SHADOW_PSM; break;
+		case VS::LIGHT_OMNI: return SHADOW_DUAL_PARABOLOID; break;
+		case VS::LIGHT_SPOT: return SHADOW_SIMPLE; break;
+	}
+
+	return Rasterizer::SHADOW_NONE;
+}
+
+Rasterizer::ShadowType RasterizerCitro3d::light_instance_get_shadow_type(RID p_light_instance,bool p_far) const {
+
+	return SHADOW_NONE;
+}
+void RasterizerCitro3d::light_instance_set_shadow_transform(RID p_light_instance, int p_index, const CameraMatrix& p_camera, const Transform& p_transform, float p_split_near,float p_split_far) {
+
+
+}
+
+int RasterizerCitro3d::light_instance_get_shadow_passes(RID p_light_instance) const {
+
+	return 0;
+}
+
+bool RasterizerCitro3d::light_instance_get_pssm_shadow_overlap(RID p_light_instance) const {
+
+	return false;
+}
+
+
+void RasterizerCitro3d::light_instance_set_custom_transform(RID p_light_instance, int p_index, const CameraMatrix& p_camera, const Transform& p_transform, float p_split_near,float p_split_far) {
+
+	LightInstance *lighti = light_instance_owner.get( p_light_instance );
+	ERR_FAIL_COND(!lighti);
+
+	ERR_FAIL_COND(lighti->base->type!=VS::LIGHT_DIRECTIONAL);
+	ERR_FAIL_INDEX(p_index,1);
+
+	lighti->custom_projection=p_camera;
+	lighti->custom_transform=p_transform;
+
+}
+void RasterizerCitro3d::shadow_clear_near() {
+
+
+}
+
+bool RasterizerCitro3d::shadow_allocate_near(RID p_light) {
+
+	return false;
+}
+
+bool RasterizerCitro3d::shadow_allocate_far(RID p_light) {
+
+	return false;
+}
+
+/* PARTICLES INSTANCE */
+
+RID RasterizerCitro3d::particles_instance_create(RID p_particles) {
+
+	ERR_FAIL_COND_V(!particles_owner.owns(p_particles),RID());
+	ParticlesInstance *particles_instance = memnew( ParticlesInstance );
+	ERR_FAIL_COND_V(!particles_instance, RID() );
+	particles_instance->particles=p_particles;
+	return particles_instance_owner.make_rid(particles_instance);
+}
+
+void RasterizerCitro3d::particles_instance_set_transform(RID p_particles_instance,const Transform& p_transform) {
+
+	ParticlesInstance *particles_instance=particles_instance_owner.get(p_particles_instance);
+	ERR_FAIL_COND(!particles_instance);
+	particles_instance->transform=p_transform;
+}
+
+
+/* RENDER API */
+/* all calls (inside begin/end shadow) are always warranted to be in the following order: */
+
+
+RID RasterizerCitro3d::viewport_data_create() {
+
+	return RID();
+}
+
+RID RasterizerCitro3d::render_target_create()
+{
+	RenderTarget* render_target = memnew(RenderTarget);
+	render_target->target = C3D_RenderTargetCreate(240, 400, GPU_RB_RGBA8, GPU_RB_DEPTH24_STENCIL8);
+	return render_target_owner.make_rid( render_target );
+}
+void RasterizerCitro3d::render_target_set_size(RID p_render_target, int p_width, int p_height)
+{
+	RenderTarget* render_target = render_target_owner.get( p_render_target );
+	
+}
+RID RasterizerCitro3d::render_target_get_texture(RID p_render_target) const{
+
+	return RID();
+
+}
+bool RasterizerCitro3d::render_target_renedered_in_frame(RID p_render_target){
+
+	return false;
+}
+
+
+void RasterizerCitro3d::begin_frame()
+{
+// 	C3D_FrameBegin(C3D_FRAME_SYNCDRAW);
+}
+
+void RasterizerCitro3d::capture_viewport(Image* r_capture) {
+
+
+}
+
+
+void RasterizerCitro3d::clear_viewport(const Color& p_color) {
+
+
+};
+
+void RasterizerCitro3d::set_viewport(const VS::ViewportRect& p_viewport) {
+
+
+
+}
+
+void RasterizerCitro3d::set_render_target(RID p_render_target, bool p_transparent_bg, bool p_vflip)
+{
+
+}
+
+
+void RasterizerCitro3d::begin_scene(RID p_viewport_data,RID p_env,VS::ScenarioDebugMode p_debug) {
+
+
+};
+
+void RasterizerCitro3d::begin_shadow_map( RID p_light_instance, int p_shadow_pass ) {
+
+}
+
+void RasterizerCitro3d::set_camera(const Transform& p_world, const CameraMatrix& p_projection, bool p_ortho_hint) {
+
+
+}
+
+void RasterizerCitro3d::add_light( RID p_light_instance ) {
+
+
+
+}
+
+
+
+
+void RasterizerCitro3d::add_mesh( const RID& p_mesh, const InstanceData *p_data) {
+
+
+}
+
+void RasterizerCitro3d::add_multimesh( const RID& p_multimesh, const InstanceData *p_data){
+
+
+
+
+}
+
+void RasterizerCitro3d::add_particles( const RID& p_particle_instance, const InstanceData *p_data){
+
+
+
+}
+
+
+
+void RasterizerCitro3d::end_scene() {
+
+
+}
+void RasterizerCitro3d::end_shadow_map() {
+
+}
+
+
+void RasterizerCitro3d::end_frame()
+{
+// 	C3D_FrameEnd(0);
+}
+
+void RasterizerCitro3d::flush_frame()
+{
+	C3D_Flush();
+}
+
+RID RasterizerCitro3d::canvas_light_occluder_create() {
+	return RID();
+}
+
+void RasterizerCitro3d::canvas_light_occluder_set_polylines(RID p_occluder, const DVector<Vector2>& p_lines) {
+
+
+}
+
+RID RasterizerCitro3d::canvas_light_shadow_buffer_create(int p_width) {
+
+	return RID();
+}
+
+void RasterizerCitro3d::canvas_light_shadow_buffer_update(RID p_buffer, const Matrix32& p_light_xform, int p_light_mask,float p_near, float p_far, CanvasLightOccluderInstance* p_occluders, CameraMatrix *p_xform_cache) {
+
+
+}
+
+void RasterizerCitro3d::canvas_debug_viewport_shadows(CanvasLight* p_lights_with_shadow) {
+
+
+}
+
+/* CANVAS API */
+
+
+void RasterizerCitro3d::begin_canvas_bg() {
+
+}
+void RasterizerCitro3d::canvas_begin() {
+
+
+
+}
+void RasterizerCitro3d::canvas_disable_blending() {
+
+
+
+}
+
+void RasterizerCitro3d::canvas_set_opacity(float p_opacity) {
+
+
+}
+
+void RasterizerCitro3d::canvas_set_blend_mode(VS::MaterialBlendMode p_mode) {
+
+
+}
+
+
+void RasterizerCitro3d::canvas_begin_rect(const Matrix32& p_transform) {
+
+
+
+}
+
+void RasterizerCitro3d::canvas_set_clip(bool p_clip, const Rect2& p_rect) {
+
+
+
+
+}
+
+void RasterizerCitro3d::canvas_end_rect() {
+
+
+}
+
+void RasterizerCitro3d::canvas_draw_line(const Point2& p_from, const Point2& p_to, const Color& p_color, float p_width, bool p_antialiased) {
+
+
+
+}
+
+void RasterizerCitro3d::canvas_draw_rect(const Rect2& p_rect, int p_flags, const Rect2& p_source,RID p_texture,const Color& p_modulate) {
+
+
+
+
+}
+void RasterizerCitro3d::canvas_draw_style_box(const Rect2& p_rect, const Rect2& p_src_region, RID p_texture,const float *p_margin, bool p_draw_center,const Color& p_modulate) {
+
+
+}
+void RasterizerCitro3d::canvas_draw_primitive(const Vector<Point2>& p_points, const Vector<Color>& p_colors,const Vector<Point2>& p_uvs, RID p_texture,float p_width) {
+
+
+
+}
+
+
+void RasterizerCitro3d::canvas_draw_polygon(int p_vertex_count, const int* p_indices, const Vector2* p_vertices, const Vector2* p_uvs, const Color* p_colors,const RID& p_texture,bool p_singlecolor) {
+
+
+
+}
+
+void RasterizerCitro3d::canvas_set_transform(const Matrix32& p_transform) {
+
+
+}
+
+void RasterizerCitro3d::canvas_render_items(CanvasItem *p_item_list,int p_z,const Color& p_modulate,CanvasLight *p_light) {
+
+
+}
+
+/* ENVIRONMENT */
+
+RID RasterizerCitro3d::environment_create() {
+
+	Environment * env = memnew( Environment );
+	return environment_owner.make_rid(env);
+}
+
+void RasterizerCitro3d::environment_set_background(RID p_env,VS::EnvironmentBG p_bg) {
+
+	ERR_FAIL_INDEX(p_bg,VS::ENV_BG_MAX);
+	Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND(!env);
+	env->bg_mode=p_bg;
+}
+
+VS::EnvironmentBG RasterizerCitro3d::environment_get_background(RID p_env) const{
+
+	const Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND_V(!env,VS::ENV_BG_MAX);
+	return env->bg_mode;
+}
+
+void RasterizerCitro3d::environment_set_background_param(RID p_env,VS::EnvironmentBGParam p_param, const Variant& p_value){
+
+	ERR_FAIL_INDEX(p_param,VS::ENV_BG_PARAM_MAX);
+	Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND(!env);
+	env->bg_param[p_param]=p_value;
+
+}
+Variant RasterizerCitro3d::environment_get_background_param(RID p_env,VS::EnvironmentBGParam p_param) const{
+
+	ERR_FAIL_INDEX_V(p_param,VS::ENV_BG_PARAM_MAX,Variant());
+	const Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND_V(!env,Variant());
+	return env->bg_param[p_param];
+
+}
+
+void RasterizerCitro3d::environment_set_enable_fx(RID p_env,VS::EnvironmentFx p_effect,bool p_enabled){
+
+	ERR_FAIL_INDEX(p_effect,VS::ENV_FX_MAX);
+	Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND(!env);
+	env->fx_enabled[p_effect]=p_enabled;
+}
+bool RasterizerCitro3d::environment_is_fx_enabled(RID p_env,VS::EnvironmentFx p_effect) const{
+
+	ERR_FAIL_INDEX_V(p_effect,VS::ENV_FX_MAX,false);
+	const Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND_V(!env,false);
+	return env->fx_enabled[p_effect];
+
+}
+
+void RasterizerCitro3d::environment_fx_set_param(RID p_env,VS::EnvironmentFxParam p_param,const Variant& p_value){
+
+	ERR_FAIL_INDEX(p_param,VS::ENV_FX_PARAM_MAX);
+	Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND(!env);
+	env->fx_param[p_param]=p_value;
+}
+Variant RasterizerCitro3d::environment_fx_get_param(RID p_env,VS::EnvironmentFxParam p_param) const{
+
+	ERR_FAIL_INDEX_V(p_param,VS::ENV_FX_PARAM_MAX,Variant());
+	const Environment * env = environment_owner.get(p_env);
+	ERR_FAIL_COND_V(!env,Variant());
+	return env->fx_param[p_param];
+
+}
+
+
+RID RasterizerCitro3d::sampled_light_dp_create(int p_width,int p_height) {
+
+	return sampled_light_owner.make_rid(memnew(SampledLight));
+}
+
+void RasterizerCitro3d::sampled_light_dp_update(RID p_sampled_light, const Color *p_data, float p_multiplier) {
+
+
+}
+
+
+/*MISC*/
+
+bool RasterizerCitro3d::is_texture(const RID& p_rid) const {
+
+	return texture_owner.owns(p_rid);
+}
+bool RasterizerCitro3d::is_material(const RID& p_rid) const {
+
+	return material_owner.owns(p_rid);
+}
+bool RasterizerCitro3d::is_mesh(const RID& p_rid) const {
+
+	return mesh_owner.owns(p_rid);
+}
+
+bool RasterizerCitro3d::is_immediate(const RID& p_rid) const {
+
+	return immediate_owner.owns(p_rid);
+}
+
+bool RasterizerCitro3d::is_multimesh(const RID& p_rid) const {
+
+	return multimesh_owner.owns(p_rid);
+}
+bool RasterizerCitro3d::is_particles(const RID &p_beam) const {
+
+	return particles_owner.owns(p_beam);
+}
+
+bool RasterizerCitro3d::is_light(const RID& p_rid) const {
+
+	return light_owner.owns(p_rid);
+}
+bool RasterizerCitro3d::is_light_instance(const RID& p_rid) const {
+
+	return light_instance_owner.owns(p_rid);
+}
+bool RasterizerCitro3d::is_particles_instance(const RID& p_rid) const {
+
+	return particles_instance_owner.owns(p_rid);
+}
+bool RasterizerCitro3d::is_skeleton(const RID& p_rid) const {
+
+	return skeleton_owner.owns(p_rid);
+}
+bool RasterizerCitro3d::is_environment(const RID& p_rid) const {
+
+	return environment_owner.owns(p_rid);
+}
+
+bool RasterizerCitro3d::is_canvas_light_occluder(const RID& p_rid) const {
+
+	return false;
+}
+
+bool RasterizerCitro3d::is_shader(const RID& p_rid) const {
+
+	return false;
+}
+
+void RasterizerCitro3d::free(const RID& p_rid) {
+
+	if (texture_owner.owns(p_rid)) {
+
+		// delete the texture
+		Texture *texture = texture_owner.get(p_rid);
+		texture_owner.free(p_rid);
+		memdelete(texture);
+
+	} else if (shader_owner.owns(p_rid)) {
+
+		// delete the texture
+		Shader *shader = shader_owner.get(p_rid);
+		shader_owner.free(p_rid);
+		memdelete(shader);
+
+	} else if (material_owner.owns(p_rid)) {
+
+		Material *material = material_owner.get( p_rid );
+		material_owner.free(p_rid);
+		memdelete(material);
+
+	} else if (mesh_owner.owns(p_rid)) {
+
+		Mesh *mesh = mesh_owner.get(p_rid);
+
+		for (int i=0;i<mesh->surfaces.size();i++) {
+
+			memdelete( mesh->surfaces[i] );
+		};
+
+		mesh->surfaces.clear();
+		mesh_owner.free(p_rid);
+		memdelete(mesh);
+
+	} else if (multimesh_owner.owns(p_rid)) {
+
+	       MultiMesh *multimesh = multimesh_owner.get(p_rid);
+	       multimesh_owner.free(p_rid);
+	       memdelete(multimesh);
+
+	} else if (immediate_owner.owns(p_rid)) {
+
+		Immediate *immediate = immediate_owner.get(p_rid);
+		immediate_owner.free(p_rid);
+		memdelete(immediate);
+
+	} else if (particles_owner.owns(p_rid)) {
+
+		Particles *particles = particles_owner.get(p_rid);
+		particles_owner.free(p_rid);
+		memdelete(particles);
+	} else if (particles_instance_owner.owns(p_rid)) {
+
+		ParticlesInstance *particles_isntance = particles_instance_owner.get(p_rid);
+		particles_instance_owner.free(p_rid);
+		memdelete(particles_isntance);
+
+	} else if (skeleton_owner.owns(p_rid)) {
+
+		Skeleton *skeleton = skeleton_owner.get( p_rid );
+		skeleton_owner.free(p_rid);
+		memdelete(skeleton);
+
+	} else if (light_owner.owns(p_rid)) {
+
+		Light *light = light_owner.get( p_rid );
+		light_owner.free(p_rid);
+		memdelete(light);
+
+	} else if (light_instance_owner.owns(p_rid)) {
+
+		LightInstance *light_instance = light_instance_owner.get( p_rid );
+		light_instance_owner.free(p_rid);
+		memdelete( light_instance );
+
+
+	} else if (environment_owner.owns(p_rid)) {
+
+		Environment *env = environment_owner.get( p_rid );
+		environment_owner.free(p_rid);
+		memdelete( env );
+	} else if (sampled_light_owner.owns(p_rid)) {
+
+		SampledLight *sampled_light = sampled_light_owner.get( p_rid );
+		ERR_FAIL_COND(!sampled_light);
+
+		sampled_light_owner.free(p_rid);
+		memdelete( sampled_light );
+
+	};
+}
+
+
+void RasterizerCitro3d::custom_shade_model_set_shader(int p_model, RID p_shader) {
+
+
+};
+
+RID RasterizerCitro3d::custom_shade_model_get_shader(int p_model) const {
+
+	return RID();
+};
+
+void RasterizerCitro3d::custom_shade_model_set_name(int p_model, const String& p_name) {
+
+};
+
+String RasterizerCitro3d::custom_shade_model_get_name(int p_model) const {
+
+	return String();
+};
+
+void RasterizerCitro3d::custom_shade_model_set_param_info(int p_model, const List<PropertyInfo>& p_info) {
+
+};
+
+void RasterizerCitro3d::custom_shade_model_get_param_info(int p_model, List<PropertyInfo>* p_info) const {
+
+};
+
+
+
+void RasterizerCitro3d::init()
+{
+}
+
+void RasterizerCitro3d::finish()
+{
+}
+
+int RasterizerCitro3d::get_render_info(VS::RenderInfo p_info)
+{
+	switch (p_info) {
+		case VS::INFO_OBJECTS_IN_FRAME:
+		case VS::INFO_VERTICES_IN_FRAME:
+		case VS::INFO_MATERIAL_CHANGES_IN_FRAME:
+		case VS::INFO_SHADER_CHANGES_IN_FRAME:
+		case VS::INFO_SURFACE_CHANGES_IN_FRAME:
+		case VS::INFO_DRAW_CALLS_IN_FRAME:
+		case VS::INFO_USAGE_VIDEO_MEM_TOTAL:
+		case VS::INFO_VIDEO_MEM_USED:
+		case VS::INFO_TEXTURE_MEM_USED:
+		case VS::INFO_VERTEX_MEM_USED:
+		default: return 0;
+	}
+}
+
+bool RasterizerCitro3d::needs_to_draw_next_frame() const
+{
+	return false;
+}
+
+
+bool RasterizerCitro3d::has_feature(VS::Features p_feature) const
+{
+	switch (p_feature) {
+		default:
+		case VS::FEATURE_MULTITHREADED:     return false;
+		case VS::FEATURE_SHADERS:           return true;
+		case VS::FEATURE_NEEDS_RELOAD_HOOK: return false;
+	}
+}
+
+void RasterizerCitro3d::restore_framebuffer()
+{
+}
+
+RasterizerCitro3d::RasterizerCitro3d()
+{
+	C3D_Init(C3D_DEFAULT_CMDBUF_SIZE);
+};
+
+RasterizerCitro3d::~RasterizerCitro3d()
+{
+	C3D_Fini();
+};
+
+#endif
diff --git a/drivers/3ds/citro3d/rasterizer_citro3d.h b/drivers/3ds/citro3d/rasterizer_citro3d.h
new file mode 100644
index 0000000..f3c3e89
--- /dev/null
+++ b/drivers/3ds/citro3d/rasterizer_citro3d.h
@@ -0,0 +1,812 @@
+/*************************************************************************/
+/*  rasterizer_citro3d.h                                                   */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#ifndef RASTERIZER_CITRO3D_H
+#define RASTERIZER_CITRO3D_H
+
+#include "servers/visual/rasterizer.h"
+
+#include "image.h"
+#include "rid.h"
+#include "servers/visual_server.h"
+#include "list.h"
+#include "map.h"
+#include "camera_matrix.h"
+#include "sort.h"
+
+#include "servers/visual/particle_system_sw.h"
+
+// Need to avoid including conflicting ctrulib Thread type
+#ifdef _3DS
+extern "C" {
+#include <3ds/types.h>
+#include <3ds/gpu/gpu.h>
+#include <3ds/gfx.h>
+#include <3ds/gpu/shaderProgram.h>
+}
+#undef _3DS
+#include <citro3d.h>
+#define _3DS
+#endif
+
+/**
+	@author Thomas Edvalson <machin3@gmail.com>
+*/
+class RasterizerCitro3d : public Rasterizer {
+
+	struct Texture {
+
+		uint32_t flags;
+// 		int width,height;
+		C3D_Tex tex;
+		Image::Format format;
+		Image image[6];
+		Texture() {
+
+			flags=tex.width=tex.height=0;
+			format=Image::FORMAT_GRAYSCALE;
+		}
+
+		~Texture() {
+
+		}
+	};
+
+	mutable RID_Owner<Texture> texture_owner;
+
+	struct Shader {
+
+		String vertex_code;
+		String fragment_code;
+		String light_code;
+		VS::ShaderMode mode;
+		Map<StringName,Variant> params;
+		int fragment_line;
+		int vertex_line;
+		int light_line;
+		bool valid;
+		bool has_alpha;
+		bool use_world_transform;
+
+	};
+
+	mutable RID_Owner<Shader> shader_owner;
+
+
+	struct Material {
+
+		bool flags[VS::MATERIAL_FLAG_MAX];
+
+		VS::MaterialDepthDrawMode depth_draw_mode;
+
+		VS::MaterialBlendMode blend_mode;
+
+		float line_width;
+		float point_size;
+
+		RID shader; // shader material
+
+		Map<StringName,Variant> shader_params;
+
+
+		Material() {
+
+
+			for(int i=0;i<VS::MATERIAL_FLAG_MAX;i++)
+				flags[i]=false;
+			flags[VS::MATERIAL_FLAG_VISIBLE]=true;
+
+			depth_draw_mode=VS::MATERIAL_DEPTH_DRAW_OPAQUE_ONLY;
+			line_width=1;
+			blend_mode=VS::MATERIAL_BLEND_MODE_MIX;
+			point_size = 1.0;
+
+		}
+	};
+	mutable RID_Owner<Material> material_owner;
+
+	void _material_check_alpha(Material *p_material);
+
+
+	struct Geometry {
+
+		enum Type {
+			GEOMETRY_INVALID,
+			GEOMETRY_SURFACE,
+			GEOMETRY_POLY,
+			GEOMETRY_PARTICLES,
+			GEOMETRY_MULTISURFACE,
+		};
+
+		Type type;
+		RID material;
+		bool has_alpha;
+		bool material_owned;
+
+		Geometry() { has_alpha=false; material_owned = false; }
+		virtual ~Geometry() {};
+	};
+
+	struct GeometryOwner {
+
+		virtual ~GeometryOwner() {}
+	};
+
+	class Mesh;
+
+	struct Surface : public Geometry {
+
+		Array data;
+		Array morph_data;
+
+		bool packed;
+		bool alpha_sort;
+		int morph_target_count;
+		AABB aabb;
+
+		VS::PrimitiveType primitive;
+
+		uint32_t format;
+		uint32_t morph_format;
+
+		Surface() {
+
+			packed=false;
+			morph_target_count=0;
+			material_owned=false;
+			format=0;
+			morph_format=0;
+
+			primitive=VS::PRIMITIVE_POINTS;
+		}
+
+		~Surface() {
+
+		}
+	};
+
+
+	struct Mesh {
+
+		bool active;
+		Vector<Surface*> surfaces;
+		int morph_target_count;
+		VS::MorphTargetMode morph_target_mode;
+		AABB custom_aabb;
+
+		mutable uint64_t last_pass;
+		Mesh() {
+			morph_target_mode=VS::MORPH_MODE_NORMALIZED;
+			morph_target_count=0;
+			last_pass=0;
+			active=false;
+		}
+	};
+	mutable RID_Owner<Mesh> mesh_owner;
+
+	struct MultiMesh;
+
+	struct MultiMeshSurface : public Geometry {
+
+		Surface *surface;
+		MultiMeshSurface() { type=GEOMETRY_MULTISURFACE; }
+	};
+
+	struct MultiMesh : public GeometryOwner {
+
+		struct Element {
+
+			Transform xform;
+			Color color;
+		};
+
+		AABB aabb;
+		RID mesh;
+		int visible;
+
+		//IDirect3DVertexBuffer9* instance_buffer;
+		Vector<Element> elements;
+
+		MultiMesh() {
+			visible=-1;
+		}
+
+
+	};
+
+
+	mutable RID_Owner<MultiMesh> multimesh_owner;
+
+	struct Immediate {
+
+
+		RID material;
+		int empty;
+	};
+
+	mutable RID_Owner<Immediate> immediate_owner;
+
+	struct Particles : public Geometry {
+
+		ParticleSystemSW data; // software particle system
+
+		Particles() {
+			type=GEOMETRY_PARTICLES;
+
+		}
+	};
+
+	mutable RID_Owner<Particles> particles_owner;
+
+	struct ParticlesInstance : public GeometryOwner {
+
+		RID particles;
+
+		ParticleSystemProcessSW particles_process;
+		Transform transform;
+
+		ParticlesInstance() {  }
+	};
+
+	mutable RID_Owner<ParticlesInstance> particles_instance_owner;
+	ParticleSystemDrawInfoSW particle_draw_info;
+
+	struct Skeleton {
+
+		Vector<Transform> bones;
+
+	};
+
+	mutable RID_Owner<Skeleton> skeleton_owner;
+
+
+	struct Light {
+
+		VS::LightType type;
+		float vars[VS::LIGHT_PARAM_MAX];
+		Color colors[3];
+		bool shadow_enabled;
+		RID projector;
+		bool volumetric_enabled;
+		Color volumetric_color;
+
+
+		Light() {
+
+			vars[VS::LIGHT_PARAM_SPOT_ATTENUATION]=1;
+			vars[VS::LIGHT_PARAM_SPOT_ANGLE]=45;
+			vars[VS::LIGHT_PARAM_ATTENUATION]=1.0;
+			vars[VS::LIGHT_PARAM_ENERGY]=1.0;
+			vars[VS::LIGHT_PARAM_RADIUS]=1.0;
+			vars[VS::LIGHT_PARAM_SHADOW_Z_OFFSET]=0.05;
+
+			colors[VS::LIGHT_COLOR_DIFFUSE]=Color(1,1,1);
+			colors[VS::LIGHT_COLOR_SPECULAR]=Color(1,1,1);
+			shadow_enabled=false;
+			volumetric_enabled=false;
+		}
+	};
+
+
+	struct Environment {
+
+
+		VS::EnvironmentBG bg_mode;
+		Variant bg_param[VS::ENV_BG_PARAM_MAX];
+		bool fx_enabled[VS::ENV_FX_MAX];
+		Variant fx_param[VS::ENV_FX_PARAM_MAX];
+
+		Environment() {
+
+			bg_mode=VS::ENV_BG_DEFAULT_COLOR;
+			bg_param[VS::ENV_BG_PARAM_COLOR]=Color(0,0,0);
+			bg_param[VS::ENV_BG_PARAM_TEXTURE]=RID();
+			bg_param[VS::ENV_BG_PARAM_CUBEMAP]=RID();
+			bg_param[VS::ENV_BG_PARAM_ENERGY]=1.0;
+
+			for(int i=0;i<VS::ENV_FX_MAX;i++)
+				fx_enabled[i]=false;
+
+			fx_param[VS::ENV_FX_PARAM_GLOW_BLUR_PASSES]=1;
+			fx_param[VS::ENV_FX_PARAM_GLOW_BLOOM]=0.0;
+			fx_param[VS::ENV_FX_PARAM_GLOW_BLOOM_TRESHOLD]=0.5;
+			fx_param[VS::ENV_FX_PARAM_DOF_BLUR_PASSES]=1;
+			fx_param[VS::ENV_FX_PARAM_DOF_BLUR_BEGIN]=100.0;
+			fx_param[VS::ENV_FX_PARAM_DOF_BLUR_RANGE]=10.0;
+			fx_param[VS::ENV_FX_PARAM_HDR_EXPOSURE]=0.4;
+			fx_param[VS::ENV_FX_PARAM_HDR_WHITE]=1.0;
+			fx_param[VS::ENV_FX_PARAM_HDR_GLOW_TRESHOLD]=0.95;
+			fx_param[VS::ENV_FX_PARAM_HDR_GLOW_SCALE]=0.2;
+			fx_param[VS::ENV_FX_PARAM_HDR_MIN_LUMINANCE]=0.4;
+			fx_param[VS::ENV_FX_PARAM_HDR_MAX_LUMINANCE]=8.0;
+			fx_param[VS::ENV_FX_PARAM_HDR_EXPOSURE_ADJUST_SPEED]=0.5;
+			fx_param[VS::ENV_FX_PARAM_FOG_BEGIN]=100.0;
+			fx_param[VS::ENV_FX_PARAM_FOG_ATTENUATION]=1.0;
+			fx_param[VS::ENV_FX_PARAM_FOG_BEGIN_COLOR]=Color(0,0,0);
+			fx_param[VS::ENV_FX_PARAM_FOG_END_COLOR]=Color(0,0,0);
+			fx_param[VS::ENV_FX_PARAM_FOG_BG]=true;
+			fx_param[VS::ENV_FX_PARAM_BCS_BRIGHTNESS]=1.0;
+			fx_param[VS::ENV_FX_PARAM_BCS_CONTRAST]=1.0;
+			fx_param[VS::ENV_FX_PARAM_BCS_SATURATION]=1.0;
+
+
+		}
+
+	};
+
+	mutable RID_Owner<Environment> environment_owner;
+
+	struct SampledLight {
+
+		int w,h;
+	};
+
+	mutable RID_Owner<SampledLight> sampled_light_owner;
+
+	struct ShadowBuffer;
+
+	struct LightInstance {
+
+		struct SplitInfo {
+
+			CameraMatrix camera;
+			Transform transform;
+			float near;
+			float far;
+		};
+
+		RID light;
+		Light *base;
+		Transform transform;
+		CameraMatrix projection;
+
+		Transform custom_transform;
+		CameraMatrix custom_projection;
+
+		Vector3 light_vector;
+		Vector3 spot_vector;
+		float linear_att;
+
+
+		LightInstance() { linear_att=1.0; }
+
+	};
+
+	mutable RID_Owner<Light> light_owner;
+	mutable RID_Owner<LightInstance> light_instance_owner;
+	
+	struct RenderTarget
+	{
+		Texture *texture_ptr;
+		RID texture;
+		C3D_RenderTarget *target;
+	};
+	mutable RID_Owner<RenderTarget> render_target_owner;
+
+
+	RID default_material;
+
+
+
+
+public:
+
+	/* TEXTURE API */
+
+	virtual RID texture_create();
+	virtual void texture_allocate(RID p_texture,int p_width, int p_height,Image::Format p_format,uint32_t p_flags=VS::TEXTURE_FLAGS_DEFAULT);
+	virtual void texture_set_data(RID p_texture,const Image& p_image,VS::CubeMapSide p_cube_side=VS::CUBEMAP_LEFT);
+	virtual Image texture_get_data(RID p_texture,VS::CubeMapSide p_cube_side=VS::CUBEMAP_LEFT) const;
+	virtual void texture_set_flags(RID p_texture,uint32_t p_flags);
+	virtual uint32_t texture_get_flags(RID p_texture) const;
+	virtual Image::Format texture_get_format(RID p_texture) const;
+	virtual uint32_t texture_get_width(RID p_texture) const;
+	virtual uint32_t texture_get_height(RID p_texture) const;
+	virtual bool texture_has_alpha(RID p_texture) const;
+	virtual void texture_set_size_override(RID p_texture,int p_width, int p_height);
+	virtual void texture_set_reload_hook(RID p_texture,ObjectID p_owner,const StringName& p_function) const;
+
+	virtual void texture_set_path(RID p_texture,const String& p_path) {}
+	virtual String texture_get_path(RID p_texture) const { return String(); }
+	virtual void texture_debug_usage(List<VS::TextureInfo> *r_info) {}
+
+	virtual void texture_set_shrink_all_x2_on_set_data(bool p_enable) {}
+
+	/* SHADER API */
+
+	virtual RID shader_create(VS::ShaderMode p_mode=VS::SHADER_MATERIAL);
+
+	virtual void shader_set_mode(RID p_shader,VS::ShaderMode p_mode);
+	virtual VS::ShaderMode shader_get_mode(RID p_shader) const;
+
+	virtual void shader_set_code(RID p_shader, const String& p_vertex, const String& p_fragment,const String& p_light,int p_vertex_ofs=0,int p_fragment_ofs=0,int p_light_ofs=0);
+	virtual String shader_get_fragment_code(RID p_shader) const;
+	virtual String shader_get_vertex_code(RID p_shader) const;
+	virtual String shader_get_light_code(RID p_shader) const;
+
+	virtual void shader_get_param_list(RID p_shader, List<PropertyInfo> *p_param_list) const;
+
+
+	virtual void shader_set_default_texture_param(RID p_shader, const StringName& p_name, RID p_texture);
+	virtual RID shader_get_default_texture_param(RID p_shader, const StringName& p_name) const;
+
+	virtual Variant shader_get_default_param(RID p_shader, const StringName& p_name);
+
+	/* COMMON MATERIAL API */
+
+	virtual RID material_create();
+
+	virtual void material_set_shader(RID p_shader_material, RID p_shader);
+	virtual RID material_get_shader(RID p_shader_material) const;
+
+	virtual void material_set_param(RID p_material, const StringName& p_param, const Variant& p_value);
+	virtual Variant material_get_param(RID p_material, const StringName& p_param) const;
+
+	virtual void material_set_flag(RID p_material, VS::MaterialFlag p_flag,bool p_enabled);
+	virtual bool material_get_flag(RID p_material,VS::MaterialFlag p_flag) const;
+
+	virtual void material_set_depth_draw_mode(RID p_material, VS::MaterialDepthDrawMode p_mode);
+	virtual VS::MaterialDepthDrawMode material_get_depth_draw_mode(RID p_material) const;
+
+	virtual void material_set_blend_mode(RID p_material,VS::MaterialBlendMode p_mode);
+	virtual VS::MaterialBlendMode material_get_blend_mode(RID p_material) const;
+
+	virtual void material_set_line_width(RID p_material,float p_line_width);
+	virtual float material_get_line_width(RID p_material) const;
+
+	/* MESH API */
+
+
+	virtual RID mesh_create();
+
+	virtual void mesh_add_surface(RID p_mesh,VS::PrimitiveType p_primitive,const Array& p_arrays,const Array& p_blend_shapes=Array(),bool p_alpha_sort=false);
+	virtual Array mesh_get_surface_arrays(RID p_mesh,int p_surface) const;
+	virtual Array mesh_get_surface_morph_arrays(RID p_mesh,int p_surface) const;
+	virtual void mesh_add_custom_surface(RID p_mesh,const Variant& p_dat);
+
+	virtual void mesh_set_morph_target_count(RID p_mesh,int p_amount);
+	virtual int mesh_get_morph_target_count(RID p_mesh) const;
+
+	virtual void mesh_set_morph_target_mode(RID p_mesh,VS::MorphTargetMode p_mode);
+	virtual VS::MorphTargetMode mesh_get_morph_target_mode(RID p_mesh) const;
+
+	virtual void mesh_surface_set_material(RID p_mesh, int p_surface, RID p_material,bool p_owned=false);
+	virtual RID mesh_surface_get_material(RID p_mesh, int p_surface) const;
+
+	virtual int mesh_surface_get_array_len(RID p_mesh, int p_surface) const;
+	virtual int mesh_surface_get_array_index_len(RID p_mesh, int p_surface) const;
+	virtual uint32_t mesh_surface_get_format(RID p_mesh, int p_surface) const;
+	virtual VS::PrimitiveType mesh_surface_get_primitive_type(RID p_mesh, int p_surface) const;
+
+	virtual void mesh_remove_surface(RID p_mesh,int p_index);
+	virtual int mesh_get_surface_count(RID p_mesh) const;
+
+	virtual AABB mesh_get_aabb(RID p_mesh,RID p_skeleton=RID()) const;
+
+	virtual void mesh_set_custom_aabb(RID p_mesh,const AABB& p_aabb);
+	virtual AABB mesh_get_custom_aabb(RID p_mesh) const;
+
+
+	/* MULTIMESH API */
+
+	virtual RID multimesh_create();
+
+	virtual void multimesh_set_instance_count(RID p_multimesh,int p_count);
+	virtual int multimesh_get_instance_count(RID p_multimesh) const;
+
+	virtual void multimesh_set_mesh(RID p_multimesh,RID p_mesh);
+	virtual void multimesh_set_aabb(RID p_multimesh,const AABB& p_aabb);
+	virtual void multimesh_instance_set_transform(RID p_multimesh,int p_index,const Transform& p_transform);
+	virtual void multimesh_instance_set_color(RID p_multimesh,int p_index,const Color& p_color);
+
+	virtual RID multimesh_get_mesh(RID p_multimesh) const;
+	virtual AABB multimesh_get_aabb(RID p_multimesh) const;;
+
+	virtual Transform multimesh_instance_get_transform(RID p_multimesh,int p_index) const;
+	virtual Color multimesh_instance_get_color(RID p_multimesh,int p_index) const;
+
+	virtual void multimesh_set_visible_instances(RID p_multimesh,int p_visible);
+	virtual int multimesh_get_visible_instances(RID p_multimesh) const;
+
+	/* IMMEDIATE API */
+
+	virtual RID immediate_create();
+	virtual void immediate_begin(RID p_immediate,VS::PrimitiveType p_rimitive,RID p_texture=RID());
+	virtual void immediate_vertex(RID p_immediate,const Vector3& p_vertex);
+	virtual void immediate_normal(RID p_immediate,const Vector3& p_normal);
+	virtual void immediate_tangent(RID p_immediate,const Plane& p_tangent);
+	virtual void immediate_color(RID p_immediate,const Color& p_color);
+	virtual void immediate_uv(RID p_immediate,const Vector2& tex_uv);
+	virtual void immediate_uv2(RID p_immediate,const Vector2& tex_uv);
+	virtual void immediate_end(RID p_immediate);
+	virtual void immediate_clear(RID p_immediate);
+	virtual void immediate_set_material(RID p_immediate,RID p_material);
+	virtual RID immediate_get_material(RID p_immediate) const;
+
+	virtual AABB immediate_get_aabb(RID p_mesh) const;
+
+	/* PARTICLES API */
+
+	virtual RID particles_create();
+
+	virtual void particles_set_amount(RID p_particles, int p_amount);
+	virtual int particles_get_amount(RID p_particles) const;
+
+	virtual void particles_set_emitting(RID p_particles, bool p_emitting);
+	virtual bool particles_is_emitting(RID p_particles) const;
+
+	virtual void particles_set_visibility_aabb(RID p_particles, const AABB& p_visibility);
+	virtual AABB particles_get_visibility_aabb(RID p_particles) const;
+
+	virtual void particles_set_emission_half_extents(RID p_particles, const Vector3& p_half_extents);
+	virtual Vector3 particles_get_emission_half_extents(RID p_particles) const;
+
+	virtual void particles_set_emission_base_velocity(RID p_particles, const Vector3& p_base_velocity);
+	virtual Vector3 particles_get_emission_base_velocity(RID p_particles) const;
+
+	virtual void particles_set_emission_points(RID p_particles, const DVector<Vector3>& p_points);
+	virtual DVector<Vector3> particles_get_emission_points(RID p_particles) const;
+
+	virtual void particles_set_gravity_normal(RID p_particles, const Vector3& p_normal);
+	virtual Vector3 particles_get_gravity_normal(RID p_particles) const;
+
+	virtual void particles_set_variable(RID p_particles, VS::ParticleVariable p_variable,float p_value);
+	virtual float particles_get_variable(RID p_particles, VS::ParticleVariable p_variable) const;
+
+	virtual void particles_set_randomness(RID p_particles, VS::ParticleVariable p_variable,float p_randomness);
+	virtual float particles_get_randomness(RID p_particles, VS::ParticleVariable p_variable) const;
+
+	virtual void particles_set_color_phase_pos(RID p_particles, int p_phase, float p_pos);
+	virtual float particles_get_color_phase_pos(RID p_particles, int p_phase) const;
+
+	virtual void particles_set_color_phases(RID p_particles, int p_phases);
+	virtual int particles_get_color_phases(RID p_particles) const;
+
+	virtual void particles_set_color_phase_color(RID p_particles, int p_phase, const Color& p_color);
+	virtual Color particles_get_color_phase_color(RID p_particles, int p_phase) const;
+
+	virtual void particles_set_attractors(RID p_particles, int p_attractors);
+	virtual int particles_get_attractors(RID p_particles) const;
+
+	virtual void particles_set_attractor_pos(RID p_particles, int p_attractor, const Vector3& p_pos);
+	virtual Vector3 particles_get_attractor_pos(RID p_particles,int p_attractor) const;
+
+	virtual void particles_set_attractor_strength(RID p_particles, int p_attractor, float p_force);
+	virtual float particles_get_attractor_strength(RID p_particles,int p_attractor) const;
+
+	virtual void particles_set_material(RID p_particles, RID p_material,bool p_owned=false);
+	virtual RID particles_get_material(RID p_particles) const;
+
+	virtual AABB particles_get_aabb(RID p_particles) const;
+
+	virtual void particles_set_height_from_velocity(RID p_particles, bool p_enable);
+	virtual bool particles_has_height_from_velocity(RID p_particles) const;
+
+	virtual void particles_set_use_local_coordinates(RID p_particles, bool p_enable);
+	virtual bool particles_is_using_local_coordinates(RID p_particles) const;
+
+	/* SKELETON API */
+
+	virtual RID skeleton_create();
+	virtual void skeleton_resize(RID p_skeleton,int p_bones);
+	virtual int skeleton_get_bone_count(RID p_skeleton) const;
+	virtual void skeleton_bone_set_transform(RID p_skeleton,int p_bone, const Transform& p_transform);
+	virtual Transform skeleton_bone_get_transform(RID p_skeleton,int p_bone);
+
+
+	/* LIGHT API */
+
+	virtual RID light_create(VS::LightType p_type);
+	virtual VS::LightType light_get_type(RID p_light) const;
+
+	virtual void light_set_color(RID p_light,VS::LightColor p_type, const Color& p_color);
+	virtual Color light_get_color(RID p_light,VS::LightColor p_type) const;
+
+	virtual void light_set_shadow(RID p_light,bool p_enabled);
+	virtual bool light_has_shadow(RID p_light) const;
+
+	virtual void light_set_volumetric(RID p_light,bool p_enabled);
+	virtual bool light_is_volumetric(RID p_light) const;
+
+	virtual void light_set_projector(RID p_light,RID p_texture);
+	virtual RID light_get_projector(RID p_light) const;
+
+	virtual void light_set_var(RID p_light, VS::LightParam p_var, float p_value);
+	virtual float light_get_var(RID p_light, VS::LightParam p_var) const;
+
+	virtual void light_set_operator(RID p_light,VS::LightOp p_op);
+	virtual VS::LightOp light_get_operator(RID p_light) const;
+
+	virtual void light_omni_set_shadow_mode(RID p_light,VS::LightOmniShadowMode p_mode);
+	virtual VS::LightOmniShadowMode light_omni_get_shadow_mode(RID p_light) const;
+
+
+	virtual void light_directional_set_shadow_mode(RID p_light,VS::LightDirectionalShadowMode p_mode);
+	virtual VS::LightDirectionalShadowMode light_directional_get_shadow_mode(RID p_light) const;
+	virtual void light_directional_set_shadow_param(RID p_light,VS::LightDirectionalShadowParam p_param, float p_value);
+	virtual float light_directional_get_shadow_param(RID p_light,VS::LightDirectionalShadowParam p_param) const;
+
+	virtual AABB light_get_aabb(RID p_poly) const;
+
+
+	virtual RID light_instance_create(RID p_light);
+	virtual void light_instance_set_transform(RID p_light_instance,const Transform& p_transform);
+
+	virtual bool light_instance_has_shadow(RID p_light_instance) const;
+	virtual bool light_instance_assign_shadow(RID p_light_instance);
+	virtual ShadowType light_instance_get_shadow_type(RID p_light_instance) const;
+	virtual int light_instance_get_shadow_passes(RID p_light_instance) const;
+	virtual bool light_instance_get_pssm_shadow_overlap(RID p_light_instance) const;
+	virtual void light_instance_set_custom_transform(RID p_light_instance, int p_index, const CameraMatrix& p_camera, const Transform& p_transform, float p_split_near=0,float p_split_far=0);
+	virtual int light_instance_get_shadow_size(RID p_light_instance, int p_index=0) const { return 1; }
+
+	virtual ShadowType light_instance_get_shadow_type(RID p_light_instance,bool p_far=false) const;
+	virtual void light_instance_set_shadow_transform(RID p_light_instance, int p_index, const CameraMatrix& p_camera, const Transform& p_transform, float p_split_near=0,float p_split_far=0);
+
+	virtual void shadow_clear_near();
+	virtual bool shadow_allocate_near(RID p_light);
+	virtual bool shadow_allocate_far(RID p_light);
+
+
+	/* PARTICLES INSTANCE */
+
+	virtual RID particles_instance_create(RID p_particles);
+	virtual void particles_instance_set_transform(RID p_particles_instance,const Transform& p_transform);
+
+	/* VIEWPORT */
+
+	virtual RID viewport_data_create();
+
+	virtual RID render_target_create();
+	virtual void render_target_set_size(RID p_render_target, int p_width, int p_height);
+	virtual RID render_target_get_texture(RID p_render_target) const;
+	virtual bool render_target_renedered_in_frame(RID p_render_target);
+
+	/* RENDER API */
+	/* all calls (inside begin/end shadow) are always warranted to be in the following order: */
+
+	virtual void begin_frame();
+
+	virtual void set_viewport(const VS::ViewportRect& p_viewport);
+	virtual void set_render_target(RID p_render_target,bool p_transparent_bg=false,bool p_vflip=false);
+	virtual void clear_viewport(const Color& p_color);
+	virtual void capture_viewport(Image* r_capture);
+
+
+	virtual void begin_scene(RID p_viewport_data,RID p_env,VS::ScenarioDebugMode p_debug);
+	virtual void begin_shadow_map( RID p_light_instance, int p_shadow_pass );
+
+	virtual void set_camera(const Transform& p_world,const CameraMatrix& p_projection,bool p_ortho_hint);
+
+	virtual void add_light( RID p_light_instance ); ///< all "add_light" calls happen before add_geometry calls
+
+
+	virtual void add_mesh( const RID& p_mesh, const InstanceData *p_data);
+	virtual void add_multimesh( const RID& p_multimesh, const InstanceData *p_data);
+	virtual void add_immediate( const RID& p_immediate, const InstanceData *p_data) {}
+	virtual void add_particles( const RID& p_particle_instance, const InstanceData *p_data);
+
+	virtual void end_scene();
+	virtual void end_shadow_map();
+
+	virtual void end_frame();
+	virtual void flush_frame();
+
+	/* CANVAS API */
+
+	virtual void begin_canvas_bg();
+	virtual void canvas_begin();
+	virtual void canvas_disable_blending();
+	virtual void canvas_set_opacity(float p_opacity);
+	virtual void canvas_set_blend_mode(VS::MaterialBlendMode p_mode);
+	virtual void canvas_begin_rect(const Matrix32& p_transform);
+	virtual void canvas_set_clip(bool p_clip, const Rect2& p_rect);
+	virtual void canvas_end_rect();
+	virtual void canvas_draw_line(const Point2& p_from, const Point2& p_to,const Color& p_color,float p_width,bool p_antialiased);
+	virtual void canvas_draw_rect(const Rect2& p_rect, int p_flags, const Rect2& p_source,RID p_texture,const Color& p_modulate);
+	virtual void canvas_draw_style_box(const Rect2& p_rect, const Rect2& p_src_region, RID p_texture,const float *p_margins, bool p_draw_center=true,const Color& p_modulate=Color(1,1,1));
+	virtual void canvas_draw_primitive(const Vector<Point2>& p_points, const Vector<Color>& p_colors,const Vector<Point2>& p_uvs, RID p_texture,float p_width);
+	virtual void canvas_draw_polygon(int p_vertex_count, const int* p_indices, const Vector2* p_vertices, const Vector2* p_uvs, const Color* p_colors,const RID& p_texture,bool p_singlecolor);
+	virtual void canvas_set_transform(const Matrix32& p_transform);
+
+	virtual void canvas_render_items(CanvasItem *p_item_list,int p_z,const Color& p_modulate,CanvasLight *p_light);
+
+	virtual RID canvas_light_occluder_create();
+	virtual void canvas_light_occluder_set_polylines(RID p_occluder, const DVector<Vector2>& p_lines);
+
+	virtual RID canvas_light_shadow_buffer_create(int p_width);
+	virtual void canvas_light_shadow_buffer_update(RID p_buffer, const Matrix32& p_light_xform, int p_light_mask,float p_near, float p_far, CanvasLightOccluderInstance* p_occluders, CameraMatrix *p_xform_cache);
+
+	virtual void canvas_debug_viewport_shadows(CanvasLight* p_lights_with_shadow);
+
+	/* ENVIRONMENT */
+
+	virtual RID environment_create();
+
+	virtual void environment_set_background(RID p_env,VS::EnvironmentBG p_bg);
+	virtual VS::EnvironmentBG environment_get_background(RID p_env) const;
+
+	virtual void environment_set_background_param(RID p_env,VS::EnvironmentBGParam p_param, const Variant& p_value);
+	virtual Variant environment_get_background_param(RID p_env,VS::EnvironmentBGParam p_param) const;
+
+	virtual void environment_set_enable_fx(RID p_env,VS::EnvironmentFx p_effect,bool p_enabled);
+	virtual bool environment_is_fx_enabled(RID p_env,VS::EnvironmentFx p_effect) const;
+
+	virtual void environment_fx_set_param(RID p_env,VS::EnvironmentFxParam p_param,const Variant& p_value);
+	virtual Variant environment_fx_get_param(RID p_env,VS::EnvironmentFxParam p_param) const;
+
+	/* SAMPLED LIGHT */
+	virtual RID sampled_light_dp_create(int p_width,int p_height);
+	virtual void sampled_light_dp_update(RID p_sampled_light,const Color *p_data,float p_multiplier);
+
+
+	/*MISC*/
+
+	virtual bool is_texture(const RID& p_rid) const;
+	virtual bool is_material(const RID& p_rid) const;
+	virtual bool is_mesh(const RID& p_rid) const;
+	virtual bool is_immediate(const RID& p_rid) const;
+	virtual bool is_multimesh(const RID& p_rid) const;
+	virtual bool is_particles(const RID &p_beam) const;
+
+	virtual bool is_light(const RID& p_rid) const;
+	virtual bool is_light_instance(const RID& p_rid) const;
+	virtual bool is_particles_instance(const RID& p_rid) const;
+	virtual bool is_skeleton(const RID& p_rid) const;
+	virtual bool is_environment(const RID& p_rid) const;
+	virtual bool is_canvas_light_occluder(const RID& p_rid) const;
+
+	virtual bool is_shader(const RID& p_rid) const;
+
+	virtual void free(const RID& p_rid);
+
+	virtual void custom_shade_model_set_shader(int p_model, RID p_shader);
+	virtual RID custom_shade_model_get_shader(int p_model) const;
+	virtual void custom_shade_model_set_name(int p_model, const String& p_name);
+	virtual String custom_shade_model_get_name(int p_model) const;
+	virtual void custom_shade_model_set_param_info(int p_model, const List<PropertyInfo>& p_info);
+	virtual void custom_shade_model_get_param_info(int p_model, List<PropertyInfo>* p_info) const;
+
+
+	virtual void init();
+	virtual void finish();
+
+	virtual int get_render_info(VS::RenderInfo p_info);
+
+	virtual bool needs_to_draw_next_frame() const;
+
+	virtual bool has_feature(VS::Features p_feature) const;
+
+	virtual void restore_framebuffer();
+
+	RasterizerCitro3d();
+	virtual ~RasterizerCitro3d();
+};
+
+
+#endif // RASTERIZER_CITRO3D_H
diff --git a/drivers/SCsub b/drivers/SCsub
index 8243483..3ed9b6b 100644
--- a/drivers/SCsub
+++ b/drivers/SCsub
@@ -10,3 +10,4 @@ SConscript('windows/SCsub');
 SConscript('windows/SCsub');
+SConscript('3ds/SCsub');
 
 # Sounds drivers
diff --git a/platform/3ds/SCsub b/platform/3ds/SCsub
new file mode 100644
index 0000000..3c78a7c
--- /dev/null
+++ b/platform/3ds/SCsub
@@ -0,0 +1,8 @@
+Import('env')
+
+
+common_3ds=[\
+	"os_3ds.cpp",\
+]
+
+env.Program('#bin/godot',['godot_3ds.cpp']+common_3ds)
diff --git a/platform/3ds/context_gl_x11.cpp b/platform/3ds/context_gl_x11.cpp
new file mode 100644
index 0000000..cd325df
--- /dev/null
+++ b/platform/3ds/context_gl_x11.cpp
@@ -0,0 +1,242 @@
+/*************************************************************************/
+/*  context_gl_x11.cpp                                                   */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#include "context_gl_x11.h"
+
+#ifdef X11_ENABLED
+#if defined(OPENGL_ENABLED) || defined(LEGACYGL_ENABLED)
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#define GLX_GLXEXT_PROTOTYPES
+#include <GL/glx.h>
+#include <GL/glxext.h>
+
+#define GLX_CONTEXT_MAJOR_VERSION_ARB		0x2091
+#define GLX_CONTEXT_MINOR_VERSION_ARB		0x2092
+
+typedef GLXContext (*GLXCREATECONTEXTATTRIBSARBPROC)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
+
+struct ContextGL_X11_Private {
+
+	::GLXContext glx_context;
+};
+
+void ContextGL_X11::release_current() {
+
+	glXMakeCurrent(x11_display, None, NULL);
+}
+
+void ContextGL_X11::make_current() {
+
+	glXMakeCurrent(x11_display, x11_window, p->glx_context);
+}
+
+void ContextGL_X11::swap_buffers() {
+
+	glXSwapBuffers(x11_display,x11_window);
+}
+
+/*
+static GLWrapperFuncPtr wrapper_get_proc_address(const char* p_function) {
+
+	//print_line(String()+"getting proc of: "+p_function);
+	GLWrapperFuncPtr func=(GLWrapperFuncPtr)glXGetProcAddress( (const GLubyte*) p_function);
+	if (!func) {
+		print_line("Couldn't find function: "+String(p_function));
+	}
+
+	return func;
+
+}*/
+
+Error ContextGL_X11::initialize() {
+
+
+	GLXCREATECONTEXTATTRIBSARBPROC glXCreateContextAttribsARB = NULL;
+
+//	const char *extensions = glXQueryExtensionsString(x11_display, DefaultScreen(x11_display));
+
+	glXCreateContextAttribsARB = (GLXCREATECONTEXTATTRIBSARBPROC)glXGetProcAddress((const GLubyte*)"glXCreateContextAttribsARB");
+
+	ERR_FAIL_COND_V( !glXCreateContextAttribsARB, ERR_UNCONFIGURED );
+
+
+	static int visual_attribs[] = {
+	    GLX_RENDER_TYPE, GLX_RGBA_BIT,
+	    GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
+	    GLX_DOUBLEBUFFER, true,
+	    GLX_RED_SIZE, 1,
+	    GLX_GREEN_SIZE, 1,
+	    GLX_BLUE_SIZE, 1,
+	    GLX_DEPTH_SIZE, 24,
+	    None
+	};
+
+	int fbcount;
+	GLXFBConfig *fbc = glXChooseFBConfig(x11_display, DefaultScreen(x11_display), visual_attribs, &fbcount);
+	ERR_FAIL_COND_V(!fbc,ERR_UNCONFIGURED);
+
+	XVisualInfo *vi = glXGetVisualFromFBConfig(x11_display, fbc[0]);
+
+	XSetWindowAttributes swa;
+
+	swa.colormap = XCreateColormap(x11_display, RootWindow(x11_display, vi->screen), vi->visual, AllocNone);
+	swa.border_pixel = 0;
+	swa.event_mask = StructureNotifyMask;
+
+	/*
+	char* windowid = getenv("GODOT_WINDOWID");
+	if (windowid) {
+
+		//freopen("/home/punto/stdout", "w", stdout);
+		//reopen("/home/punto/stderr", "w", stderr);
+		x11_window = atol(windowid);
+	} else {
+	*/
+		x11_window = XCreateWindow(x11_display, RootWindow(x11_display, vi->screen), 0, 0, OS::get_singleton()->get_video_mode().width, OS::get_singleton()->get_video_mode().height, 0, vi->depth, InputOutput, vi->visual, CWBorderPixel|CWColormap|CWEventMask, &swa);
+		ERR_FAIL_COND_V(!x11_window,ERR_UNCONFIGURED);
+		XMapWindow(x11_display, x11_window);
+		while(true) {
+			// wait for mapnotify (window created)
+			XEvent e;
+			XNextEvent(x11_display, &e);
+			if (e.type == MapNotify)
+				break;
+		}
+		//};
+
+
+	if (!opengl_3_context) {
+		//oldstyle context:
+		p->glx_context = glXCreateContext(x11_display, vi, 0, GL_TRUE);
+	} else {
+		static int context_attribs[] = {
+			GLX_CONTEXT_MAJOR_VERSION_ARB, 3,
+			GLX_CONTEXT_MINOR_VERSION_ARB, 0,
+			None
+		};
+
+		p->glx_context = glXCreateContextAttribsARB(x11_display, fbc[0], NULL, true, context_attribs);
+		ERR_FAIL_COND_V(!p->glx_context,ERR_UNCONFIGURED);
+	}
+
+	glXMakeCurrent(x11_display, x11_window, p->glx_context);
+
+	/*
+	glWrapperInit(wrapper_get_proc_address);
+	glFlush();
+
+	glXSwapBuffers(x11_display,x11_window);
+*/
+	//glXMakeCurrent(x11_display, None, NULL);
+
+	XFree( vi );
+	XFree( fbc );
+
+	return OK;
+}
+
+int ContextGL_X11::get_window_width() {
+
+	XWindowAttributes xwa;
+	XGetWindowAttributes(x11_display,x11_window,&xwa);
+
+	return xwa.width;
+}
+
+int ContextGL_X11::get_window_height() {
+	XWindowAttributes xwa;
+	XGetWindowAttributes(x11_display,x11_window,&xwa);
+
+	return xwa.height;
+}
+
+void ContextGL_X11::set_use_vsync(bool p_use) {
+	static bool setup = false;
+	static PFNGLXSWAPINTERVALEXTPROC glXSwapIntervalEXT = NULL;
+	static PFNGLXSWAPINTERVALSGIPROC glXSwapIntervalMESA = NULL;
+	static PFNGLXSWAPINTERVALSGIPROC glXSwapIntervalSGI = NULL;
+
+	if (!setup) {
+		setup = true;
+		String extensions = glXQueryExtensionsString(x11_display, DefaultScreen(x11_display));
+		if (extensions.find("GLX_EXT_swap_control") != -1)
+			glXSwapIntervalEXT  = (PFNGLXSWAPINTERVALEXTPROC) glXGetProcAddressARB((const GLubyte*)"glXSwapIntervalEXT");
+		if (extensions.find("GLX_MESA_swap_control") != -1)
+			glXSwapIntervalMESA = (PFNGLXSWAPINTERVALSGIPROC) glXGetProcAddressARB((const GLubyte*)"glXSwapIntervalMESA");
+		if (extensions.find("GLX_SGI_swap_control") != -1)
+			glXSwapIntervalSGI  = (PFNGLXSWAPINTERVALSGIPROC) glXGetProcAddressARB((const GLubyte*)"glXSwapIntervalSGI");
+	}
+	int val = p_use ? 1:0;
+	if (glXSwapIntervalMESA) {
+		glXSwapIntervalMESA(val);
+	}
+	else if (glXSwapIntervalSGI) {
+		glXSwapIntervalSGI(val);
+	}
+	else if (glXSwapIntervalEXT) {
+		GLXDrawable drawable = glXGetCurrentDrawable();
+		glXSwapIntervalEXT(x11_display, drawable, val);
+	}
+	else return;
+	use_vsync = p_use;
+}
+bool ContextGL_X11::is_using_vsync() const {
+
+	return use_vsync;
+}
+
+
+ContextGL_X11::ContextGL_X11(::Display *p_x11_display,::Window &p_x11_window,const OS::VideoMode& p_default_video_mode,bool p_opengl_3_context) : x11_window(p_x11_window) {
+
+	default_video_mode=p_default_video_mode;
+	x11_display=p_x11_display;
+
+	opengl_3_context=p_opengl_3_context;
+
+	double_buffer=false;
+	direct_render=false;
+	glx_minor=glx_major=0;
+	p = memnew( ContextGL_X11_Private );
+	p->glx_context=0;
+	use_vsync=false;
+}
+
+
+ContextGL_X11::~ContextGL_X11() {
+	release_current();
+	glXDestroyContext( x11_display, p->glx_context );
+
+	memdelete( p );
+}
+
+
+#endif
+#endif
diff --git a/platform/3ds/context_gl_x11.h b/platform/3ds/context_gl_x11.h
new file mode 100644
index 0000000..4474542
--- /dev/null
+++ b/platform/3ds/context_gl_x11.h
@@ -0,0 +1,80 @@
+/*************************************************************************/
+/*  context_gl_x11.h                                                     */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#ifndef CONTEXT_GL_X11_H
+#define CONTEXT_GL_X11_H
+
+/**
+	@author Juan Linietsky <reduzio@gmail.com>
+*/
+#ifdef X11_ENABLED
+
+#if defined(OPENGL_ENABLED) || defined(LEGACYGL_ENABLED)
+
+
+
+#include "os/os.h"
+#include "drivers/gl_context/context_gl.h"
+#include <X11/Xlib.h>
+
+struct ContextGL_X11_Private;
+
+class ContextGL_X11 : public ContextGL {
+
+	ContextGL_X11_Private *p;
+	OS::VideoMode default_video_mode;
+//	::Colormap x11_colormap;
+	::Display *x11_display;
+	::Window& x11_window;
+	bool double_buffer;
+	bool direct_render;
+	int glx_minor,glx_major;
+	bool opengl_3_context;
+	bool use_vsync;
+public:
+
+	virtual void release_current();
+	virtual void make_current();
+	virtual void swap_buffers();
+	virtual int get_window_width();
+	virtual int get_window_height();
+
+	virtual Error initialize();
+
+	virtual void set_use_vsync(bool p_use);
+	virtual bool is_using_vsync() const;
+
+	ContextGL_X11(::Display *p_x11_display,::Window &p_x11_window,const OS::VideoMode& p_default_video_mode,bool p_opengl_3_context);
+	~ContextGL_X11();
+
+};
+
+#endif
+
+#endif
+#endif
diff --git a/platform/3ds/detect.py b/platform/3ds/detect.py
new file mode 100644
index 0000000..205c69b
--- /dev/null
+++ b/platform/3ds/detect.py
@@ -0,0 +1,188 @@
+
+import os
+import sys
+import platform
+
+
+def is_active():
+	return True
+
+def get_name():
+        return "3ds"
+
+
+def can_build():
+
+	if (not os.environ.has_key("DEVKITPRO")):
+		return False
+	if (not os.environ.has_key("CTRULIB")):
+		return False
+	if (os.name=="nt"):
+		return False
+	
+	envstr='PKG_CONFIG_DIR= PKG_CONFIG_PATH= PKG_CONFIG_LIBDIR=${DEVKITPRO}/portlibs/3ds/lib/pkgconfig:${DEVKITPRO}/portlibs/armv6k/lib/pkgconfig'
+
+	errorval=os.system("pkg-config --version > /dev/null")
+	if (errorval):
+		print("pkg-config not found... 3ds disabled.")
+		return False
+	
+	for package in ['zlib', 'libpng']:
+		errorval=os.system("{} pkg-config {} --modversion > /dev/null".format(envstr, package))
+		if (errorval):
+			print(package+" not found... 3ds disabled.")
+			return False
+
+	return True # 3DS enabled
+
+def get_opts():
+
+	return [
+	('debug_release', 'Add debug symbols to release version','no'),
+	]
+
+def get_flags():
+
+	return [
+	('builtin_zlib', 'no'),
+	('tools', 'no'),
+	("openssl", "no"),
+	('freetype','builtin'),
+	]
+
+
+
+def configure(env):
+	
+	env["bits"]="32"
+
+	env.Append(CPPPATH=['#platform/3ds'])
+	env["CC"]="arm-none-eabi-gcc"
+	env["CXX"]="arm-none-eabi-g++"
+	env["LD"]="arm-none-eabi-g++"
+	env["AR"]="arm-none-eabi-ar"
+	env["RANLIB"]="arm-none-eabi-ranlib"
+	env["AS"]="arm-none-eabi-as"
+	
+	env.Append(CCFLAGS=['-march=armv6k', '-mtune=mpcore', '-mfloat-abi=hard', '-mword-relocations'])
+	env.Append(CCFLAGS=['-fno-omit-frame-pointer'])
+	
+	devkitpro_path = os.environ["DEVKITPRO"]
+	ctrulib_path = os.environ["CTRULIB"]
+	
+	env.Append(CPPPATH=[devkitpro_path+"/portlibs/armv6k/include", devkitpro_path+"/portlibs/3ds/include"])
+	env.Append(LIBPATH=[devkitpro_path+"/portlibs/armv6k/lib", devkitpro_path+"/portlibs/3ds/lib"])
+	
+	env.Append(LINKFLAGS=['-specs=3dsx.specs', '-g', '-march=armv6k', '-mtune=mpcore', '-mfloat-abi=hard'])
+	env.Append(CPPPATH=[ctrulib_path+"/include"])
+	env.Append(LIBPATH=[ctrulib_path+"/lib"])
+	env.Append(LIBS=["citro3d","ctru"])
+	env.Append(LIBS=["png","z"])
+	
+	#if (env["use_llvm"]=="yes"):
+		#if 'clang++' not in env['CXX']:
+			#env["CC"]="clang"
+			#env["CXX"]="clang++"
+			#env["LD"]="clang++"
+		#env.Append(CPPFLAGS=['-DTYPED_METHOD_BIND'])
+		#env.extra_suffix=".llvm"
+
+		#if (env["colored"]=="yes"):
+			#if sys.stdout.isatty():
+				#env.Append(CXXFLAGS=["-fcolor-diagnostics"])
+
+	#if (env["use_sanitizer"]=="yes"):
+		#env.Append(CXXFLAGS=['-fsanitize=address','-fno-omit-frame-pointer'])
+		#env.Append(LINKFLAGS=['-fsanitize=address'])
+		#env.extra_suffix+="s"
+
+	#if (env["use_leak_sanitizer"]=="yes"):
+		#env.Append(CXXFLAGS=['-fsanitize=address','-fno-omit-frame-pointer'])
+		#env.Append(LINKFLAGS=['-fsanitize=address'])
+		#env.extra_suffix+="s"
+
+
+	#if (env["tools"]=="no"):
+	#	#no tools suffix
+	#	env['OBJSUFFIX'] = ".nt"+env['OBJSUFFIX']
+	#	env['LIBSUFFIX'] = ".nt"+env['LIBSUFFIX']
+
+	env.Append(CCFLAGS=['-D_3DS', '-DNEED_LONG_INT', '-DLIBC_FILEIO_ENABLED'])
+
+	if (env["target"]=="release"):
+		if (env["debug_release"]=="yes"):
+			env.Append(CCFLAGS=['-g2'])
+		else:
+			env.Append(CCFLAGS=['-O3','-ffast-math'])
+	elif (env["target"]=="release_debug"):
+		env.Append(CCFLAGS=['-O2','-ffast-math','-DDEBUG_ENABLED'])
+		if (env["debug_release"]=="yes"):
+			env.Append(CCFLAGS=['-g2'])
+	elif (env["target"]=="debug"):
+		env.Append(CCFLAGS=['-g2', '-Wall','-DDEBUG_ENABLED','-DDEBUG_MEMORY_ENABLED'])
+
+	#env.ParseConfig('pkg-config x11 --cflags --libs')
+	#env.ParseConfig('pkg-config xrandr --cflags --libs')
+
+	if (env["openssl"]=="yes"):
+		env.ParseConfig('pkg-config openssl --cflags --libs')
+
+	if (env["freetype"]=="yes"):
+		env.ParseConfig('pkg-config freetype2 --cflags --libs')
+
+
+	#env.Append(CPPFLAGS=['-DOPENGL_ENABLED'])
+
+	#if (platform.system() == "Linux"):
+		#env.Append(CPPFLAGS=["-DJOYDEV_ENABLED"])
+	#if (env["udev"]=="yes"):
+		## pkg-config returns 0 when the lib exists...
+		#found_udev = not os.system("pkg-config --exists libudev")
+
+		#if (found_udev):
+			#print("Enabling udev support")
+			#env.Append(CPPFLAGS=["-DUDEV_ENABLED"])
+			#env.ParseConfig('pkg-config libudev --cflags --libs')
+		#else:
+			#print("libudev development libraries not found, disabling udev support")
+
+	#if (env["pulseaudio"]=="yes"):
+		#if not os.system("pkg-config --exists libpulse-simple"):
+			#print("Enabling PulseAudio")
+			#env.Append(CPPFLAGS=["-DPULSEAUDIO_ENABLED"])
+			#env.ParseConfig('pkg-config --cflags --libs libpulse-simple')
+		#else:
+			#print("PulseAudio development libraries not found, disabling driver")
+
+	#env.Append(CPPFLAGS=['-DX11_ENABLED','-DUNIX_ENABLED','-DGLES2_ENABLED','-DGLES_OVER_GL'])
+	#env.Append(LIBS=['GL', 'pthread', 'z'])
+	#if (platform.system() == "Linux"):
+		#env.Append(LIBS='dl')
+	#env.Append(CPPFLAGS=['-DMPC_FIXED_POINT'])
+
+#host compiler is default..
+
+	#if (is64 and env["bits"]=="32"):
+		#env.Append(CPPFLAGS=['-m32'])
+		#env.Append(LINKFLAGS=['-m32','-L/usr/lib/i386-linux-gnu'])
+	#elif (not is64 and env["bits"]=="64"):
+		#env.Append(CPPFLAGS=['-m64'])
+		#env.Append(LINKFLAGS=['-m64','-L/usr/lib/i686-linux-gnu'])
+
+
+	import methods
+	
+	env.disabled_modules = ['enet']
+
+	#env.Append( BUILDERS = { 'GLSL120' : env.Builder(action = methods.build_legacygl_headers, suffix = 'glsl.h',src_suffix = '.glsl') } )
+	#env.Append( BUILDERS = { 'GLSL' : env.Builder(action = methods.build_glsl_headers, suffix = 'glsl.h',src_suffix = '.glsl') } )
+	#env.Append( BUILDERS = { 'GLSL120GLES' : env.Builder(action = methods.build_gles2_headers, suffix = 'glsl.h',src_suffix = '.glsl') } )
+	#env.Append( BUILDERS = { 'HLSL9' : env.Builder(action = methods.build_hlsl_dx9_headers, suffix = 'hlsl.h',src_suffix = '.hlsl') } )
+
+	#if (env["use_static_cpp"]=="yes"):
+		#env.Append(LINKFLAGS=['-static-libstdc++'])
+
+	#list_of_x86 = ['x86_64', 'x86', 'i386', 'i586']
+	#if any(platform.machine() in s for s in list_of_x86):
+		#env["x86_opt_gcc"]=True
+
diff --git a/platform/3ds/export/export.cpp b/platform/3ds/export/export.cpp
new file mode 100644
index 0000000..ad28680
--- /dev/null
+++ b/platform/3ds/export/export.cpp
@@ -0,0 +1,50 @@
+/*************************************************************************/
+/*  export.cpp                                                           */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#include "export.h"
+#include "platform/3ds/logo.h"
+#include "tools/editor/editor_import_export.h"
+#include "scene/resources/texture.h"
+
+void register_3ds_exporter() {
+
+	Image img(_3ds_logo);
+	Ref<ImageTexture> logo = memnew( ImageTexture );
+	logo->create_from_image(img);
+
+	{
+		Ref<EditorExportPlatformPC> exporter = Ref<EditorExportPlatformPC>( memnew(EditorExportPlatformPC) );
+		exporter->set_binary_extension(".elf");
+		exporter->set_release_binary32("3ds_release");
+		exporter->set_debug_binary32("3ds_debug");
+		exporter->set_name("Nintendo 3DS");
+		exporter->set_logo(logo);
+		EditorImportExport::get_singleton()->add_export_platform(exporter);
+	}
+
+}
diff --git a/platform/3ds/export/export.h b/platform/3ds/export/export.h
new file mode 100644
index 0000000..5608c48
--- /dev/null
+++ b/platform/3ds/export/export.h
@@ -0,0 +1,29 @@
+/*************************************************************************/
+/*  export.h                                                             */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+void register_3ds_exporter();
diff --git a/platform/3ds/godot_3ds.cpp b/platform/3ds/godot_3ds.cpp
new file mode 100644
index 0000000..0c337bb
--- /dev/null
+++ b/platform/3ds/godot_3ds.cpp
@@ -0,0 +1,56 @@
+/*************************************************************************/
+/*  godot_3ds.cpp                                                        */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#include "main/main.h"
+#include "os_3ds.h"
+#include <stdio.h>
+
+
+int main(int argc, char* argv[])
+{
+	OS_3DS os;
+	printf("test1 ");
+	
+	char* args[] = {"-path", "motion"};
+// 	char* args[] = {"motion"};
+
+// 	Error err  = Main::setup(argv[0],argc-1,&argv[1]);
+	Error err  = Main::setup("3ds", 2, args);
+// 	Error err  = Main::setup("3ds", 0, NULL);
+	if (err==OK)
+	{
+		printf("Running...\n");
+
+		if (Main::start())
+			os.run(); // it is actually the OS that decides how to run
+		Main::cleanup();
+	}
+
+	// OS_3DS destructor to exit ctrulib stuff
+	return 0;
+}
diff --git a/platform/3ds/key_mapping_x11.cpp b/platform/3ds/key_mapping_x11.cpp
new file mode 100644
index 0000000..6443d14
--- /dev/null
+++ b/platform/3ds/key_mapping_x11.cpp
@@ -0,0 +1,1813 @@
+/*************************************************************************/
+/*  key_mapping_x11.cpp                                                  */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#include "key_mapping_x11.h"
+
+
+/***** SCAN CODE CONVERSION ******/
+
+struct _XTranslatePair {
+
+	KeySym keysym;
+	unsigned int keycode;
+};
+
+static _XTranslatePair _xkeysym_to_keycode[]={
+  // misc keys
+
+	{ XK_Escape,                  KEY_ESCAPE   },
+	{ XK_Tab,                     KEY_TAB   },
+	{ XK_ISO_Left_Tab,            KEY_BACKTAB   },
+	{ XK_BackSpace,               KEY_BACKSPACE   },
+	{ XK_Return,                  KEY_RETURN   },
+	{ XK_Insert,                  KEY_INSERT   },
+	{ XK_Delete,                  KEY_DELETE   },
+	{ XK_Clear,                   KEY_DELETE   },
+	{ XK_Pause,                   KEY_PAUSE   },
+	{ XK_Print,                   KEY_PRINT   },
+	{ XK_Home,                    KEY_HOME   },
+	{ XK_End,                     KEY_END   },
+	{ XK_Left,                    KEY_LEFT   },
+	{ XK_Up,                      KEY_UP   },
+	{ XK_Right,                   KEY_RIGHT   },
+	{ XK_Down,                    KEY_DOWN   },
+	{ XK_Prior,                   KEY_PAGEUP   },
+	{ XK_Next,                    KEY_PAGEDOWN   },
+	{ XK_Shift_L,                 KEY_SHIFT   },
+	{ XK_Shift_R,                 KEY_SHIFT   },
+	{ XK_Shift_Lock,              KEY_SHIFT   },
+	{ XK_Control_L,               KEY_CONTROL   },
+	{ XK_Control_R,               KEY_CONTROL   },
+	{ XK_Meta_L,                  KEY_META   },
+	{ XK_Meta_R,                  KEY_META   },
+	{ XK_Alt_L,                   KEY_ALT   },
+	{ XK_Alt_R,                   KEY_ALT   },
+	{ XK_Caps_Lock,               KEY_CAPSLOCK   },
+	{ XK_Num_Lock,                KEY_NUMLOCK   },
+	{ XK_Scroll_Lock,             KEY_SCROLLLOCK   },
+	{ XK_Super_L,                 KEY_SUPER_L   },
+	{ XK_Super_R,                 KEY_SUPER_R   },
+	{ XK_Menu,                    KEY_MENU   },
+	{ XK_Hyper_L,                 KEY_HYPER_L   },
+	{ XK_Hyper_R,                 KEY_HYPER_R   },
+	{ XK_Help,                    KEY_HELP   },
+	{ XK_KP_Space,                KEY_SPACE   },
+	{ XK_KP_Tab,                  KEY_TAB   },
+	{ XK_KP_Enter,                KEY_ENTER   },
+	{ XK_Home,                 KEY_HOME   },
+	{ XK_Left,                 KEY_LEFT   },
+	{ XK_Up,                   KEY_UP   },
+	{ XK_Right,                KEY_RIGHT   },
+	{ XK_Down,                 KEY_DOWN   },
+	{ XK_Prior,                KEY_PAGEUP   },
+	{ XK_Next,                 KEY_PAGEDOWN   },
+	{ XK_End,                  KEY_END   },
+	{ XK_Begin,                KEY_CLEAR   },
+	{ XK_Insert,               KEY_INSERT   },
+	{ XK_Delete,               KEY_DELETE   },
+//	{ XK_KP_Equal,                KEY_EQUAL   },
+//	{ XK_KP_Separator,            KEY_COMMA   },
+	{ XK_KP_Decimal,              KEY_KP_PERIOD   },
+	{ XK_KP_Delete,              KEY_KP_PERIOD   },
+	{ XK_KP_Enter,		      KEY_KP_ENTER },
+	{ XK_KP_Multiply,	      KEY_KP_MULTIPLY},
+	{ XK_KP_Divide,		     KEY_KP_DIVIDE},
+	{ XK_KP_Subtract,		KEY_KP_SUBTRACT},
+	{ XK_KP_Add,		KEY_KP_ADD},
+	{ XK_KP_0,		KEY_KP_0},
+	{ XK_KP_1,		KEY_KP_1},
+	{ XK_KP_2,		KEY_KP_2},
+	{ XK_KP_3,		KEY_KP_3},
+	{ XK_KP_4,		KEY_KP_4},
+	{ XK_KP_5,		KEY_KP_5},
+	{ XK_KP_6,		KEY_KP_6},
+	{ XK_KP_7,		KEY_KP_7},
+	{ XK_KP_8,		KEY_KP_8},
+	{ XK_KP_9,		KEY_KP_9},
+	// same but with numlock
+	{ XK_KP_Insert,		KEY_KP_0},
+	{ XK_KP_End,		KEY_KP_1},
+	{ XK_KP_Down,		KEY_KP_2},
+	{ XK_KP_Page_Down,	KEY_KP_3},
+	{ XK_KP_Left,		KEY_KP_4},
+	{ XK_KP_Begin,		KEY_KP_5},
+	{ XK_KP_Right,		KEY_KP_6},
+	{ XK_KP_Home,		KEY_KP_7},
+	{ XK_KP_Up,		KEY_KP_8},
+	{ XK_KP_Page_Up,		KEY_KP_9},
+	{ XK_F1,		KEY_F1},
+	{ XK_F2,		KEY_F2},
+	{ XK_F3,		KEY_F3},
+	{ XK_F4,		KEY_F4},
+	{ XK_F5,		KEY_F5},
+	{ XK_F6,		KEY_F6},
+	{ XK_F7,		KEY_F7},
+	{ XK_F8,		KEY_F8},
+	{ XK_F9,		KEY_F9},
+	{ XK_F10,		KEY_F10},
+	{ XK_F11,		KEY_F11},
+	{ XK_F12,		KEY_F12},
+	{ XK_F13,		KEY_F13},
+	{ XK_F14,		KEY_F14},
+	{ XK_F15,		KEY_F15},
+	{ XK_F16,		KEY_F16},
+
+    // media keys
+	{ XF86XK_Back,                KEY_BACK   },
+	{ XF86XK_Forward,             KEY_FORWARD   },
+	{ XF86XK_Stop,                KEY_STOP   },
+	{ XF86XK_Refresh,             KEY_REFRESH   },
+	{ XF86XK_Favorites,           KEY_FAVORITES   },
+	{ XF86XK_AudioMedia,          KEY_LAUNCHMEDIA   },
+	{ XF86XK_OpenURL,             KEY_OPENURL   },
+	{ XF86XK_HomePage,            KEY_HOMEPAGE   },
+	{ XF86XK_Search,              KEY_SEARCH   },
+	{ XF86XK_AudioLowerVolume,    KEY_VOLUMEDOWN   },
+	{ XF86XK_AudioMute,           KEY_VOLUMEMUTE   },
+	{ XF86XK_AudioRaiseVolume,    KEY_VOLUMEUP   },
+	{ XF86XK_AudioPlay,           KEY_MEDIAPLAY   },
+	{ XF86XK_AudioStop,           KEY_MEDIASTOP   },
+	{ XF86XK_AudioPrev,           KEY_MEDIAPREVIOUS   },
+	{ XF86XK_AudioNext,           KEY_MEDIANEXT   },
+	{ XF86XK_AudioRecord,         KEY_MEDIARECORD   },
+
+    // launch keys
+	{ XF86XK_Mail,                KEY_LAUNCHMAIL   },
+	{ XF86XK_MyComputer,          KEY_LAUNCH0   },
+	{ XF86XK_Calculator,          KEY_LAUNCH1   },
+	{ XF86XK_Standby,             KEY_STANDBY   },
+
+	{ XF86XK_Launch0,             KEY_LAUNCH2   },
+	{ XF86XK_Launch1,             KEY_LAUNCH3   },
+	{ XF86XK_Launch2,             KEY_LAUNCH4   },
+	{ XF86XK_Launch3,             KEY_LAUNCH5   },
+	{ XF86XK_Launch4,             KEY_LAUNCH6   },
+	{ XF86XK_Launch5,             KEY_LAUNCH7   },
+	{ XF86XK_Launch6,             KEY_LAUNCH8   },
+	{ XF86XK_Launch7,             KEY_LAUNCH9   },
+	{ XF86XK_Launch8,             KEY_LAUNCHA   },
+	{ XF86XK_Launch9,             KEY_LAUNCHB   },
+	{ XF86XK_LaunchA,             KEY_LAUNCHC   },
+	{ XF86XK_LaunchB,             KEY_LAUNCHD   },
+	{ XF86XK_LaunchC,             KEY_LAUNCHE   },
+	{ XF86XK_LaunchD,             KEY_LAUNCHF   },
+
+	{0,                          0  }
+};
+
+
+unsigned int KeyMappingX11::get_keycode(KeySym p_keysym) {
+
+	// kinda bruteforce.. could optimize.
+
+	if (p_keysym<0x100) // Latin 1, maps 1-1
+		return p_keysym;
+
+	// look for special key
+	for(int idx=0;_xkeysym_to_keycode[idx].keysym!=0;idx++) {
+
+		if (_xkeysym_to_keycode[idx].keysym==p_keysym)
+			return  _xkeysym_to_keycode[idx].keycode;
+	}
+
+	return 0;
+}
+
+KeySym KeyMappingX11::get_keysym(unsigned int p_code) {
+
+	// kinda bruteforce.. could optimize.
+
+	if (p_code<0x100) // Latin 1, maps 1-1
+		return p_code;
+
+	// look for special key
+	for(int idx=0;_xkeysym_to_keycode[idx].keysym!=0;idx++) {
+
+		if (_xkeysym_to_keycode[idx].keycode==p_code)
+			return  _xkeysym_to_keycode[idx].keysym;
+	}
+
+	return 0;
+}
+
+
+/***** UNICODE CONVERSION ******/
+
+// Tables taken from FOX toolkit
+
+struct _XTranslateUnicodePair {
+
+	KeySym keysym;
+	unsigned int unicode;
+};
+
+enum {
+
+	_KEYSYM_MAX=759
+};
+
+static _XTranslateUnicodePair _xkeysym_to_unicode[_KEYSYM_MAX] = {
+	{ 0x01A1, 0x0104 },
+	{ 0x01A2, 0x02D8 },
+	{ 0x01A3, 0x0141 },
+	{ 0x01A5, 0x013D },
+	{ 0x01A6, 0x015A },
+	{ 0x01A9, 0x0160 },
+	{ 0x01AA, 0x015E },
+	{ 0x01AB, 0x0164 },
+	{ 0x01AC, 0x0179 },
+	{ 0x01AE, 0x017D },
+	{ 0x01AF, 0x017B },
+	{ 0x01B1, 0x0105 },
+	{ 0x01B2, 0x02DB },
+	{ 0x01B3, 0x0142 },
+	{ 0x01B5, 0x013E },
+	{ 0x01B6, 0x015B },
+	{ 0x01B7, 0x02C7 },
+	{ 0x01B9, 0x0161 },
+	{ 0x01BA, 0x015F },
+	{ 0x01BB, 0x0165 },
+	{ 0x01BC, 0x017A },
+	{ 0x01BD, 0x02DD },
+	{ 0x01BE, 0x017E },
+	{ 0x01BF, 0x017C },
+	{ 0x01C0, 0x0154 },
+	{ 0x01C3, 0x0102 },
+	{ 0x01C5, 0x0139 },
+	{ 0x01C6, 0x0106 },
+	{ 0x01C8, 0x010C },
+	{ 0x01CA, 0x0118 },
+	{ 0x01CC, 0x011A },
+	{ 0x01CF, 0x010E },
+	{ 0x01D0, 0x0110 },
+	{ 0x01D1, 0x0143 },
+	{ 0x01D2, 0x0147 },
+	{ 0x01D5, 0x0150 },
+	{ 0x01D8, 0x0158 },
+	{ 0x01D9, 0x016E },
+	{ 0x01DB, 0x0170 },
+	{ 0x01DE, 0x0162 },
+	{ 0x01E0, 0x0155 },
+	{ 0x01E3, 0x0103 },
+	{ 0x01E5, 0x013A },
+	{ 0x01E6, 0x0107 },
+	{ 0x01E8, 0x010D },
+	{ 0x01EA, 0x0119 },
+	{ 0x01EC, 0x011B },
+	{ 0x01EF, 0x010F },
+	{ 0x01F0, 0x0111 },
+	{ 0x01F1, 0x0144 },
+	{ 0x01F2, 0x0148 },
+	{ 0x01F5, 0x0151 },
+	{ 0x01F8, 0x0159 },
+	{ 0x01F9, 0x016F },
+	{ 0x01FB, 0x0171 },
+	{ 0x01FE, 0x0163 },
+	{ 0x01FF, 0x02D9 },
+	{ 0x02A1, 0x0126 },
+	{ 0x02A6, 0x0124 },
+	{ 0x02A9, 0x0130 },
+	{ 0x02AB, 0x011E },
+	{ 0x02AC, 0x0134 },
+	{ 0x02B1, 0x0127 },
+	{ 0x02B6, 0x0125 },
+	{ 0x02B9, 0x0131 },
+	{ 0x02BB, 0x011F },
+	{ 0x02BC, 0x0135 },
+	{ 0x02C5, 0x010A },
+	{ 0x02C6, 0x0108 },
+	{ 0x02D5, 0x0120 },
+	{ 0x02D8, 0x011C },
+	{ 0x02DD, 0x016C },
+	{ 0x02DE, 0x015C },
+	{ 0x02E5, 0x010B },
+	{ 0x02E6, 0x0109 },
+	{ 0x02F5, 0x0121 },
+	{ 0x02F8, 0x011D },
+	{ 0x02FD, 0x016D },
+	{ 0x02FE, 0x015D },
+	{ 0x03A2, 0x0138 },
+	{ 0x03A3, 0x0156 },
+	{ 0x03A5, 0x0128 },
+	{ 0x03A6, 0x013B },
+	{ 0x03AA, 0x0112 },
+	{ 0x03AB, 0x0122 },
+	{ 0x03AC, 0x0166 },
+	{ 0x03B3, 0x0157 },
+	{ 0x03B5, 0x0129 },
+	{ 0x03B6, 0x013C },
+	{ 0x03BA, 0x0113 },
+	{ 0x03BB, 0x0123 },
+	{ 0x03BC, 0x0167 },
+	{ 0x03BD, 0x014A },
+	{ 0x03BF, 0x014B },
+	{ 0x03C0, 0x0100 },
+	{ 0x03C7, 0x012E },
+	{ 0x03CC, 0x0116 },
+	{ 0x03CF, 0x012A },
+	{ 0x03D1, 0x0145 },
+	{ 0x03D2, 0x014C },
+	{ 0x03D3, 0x0136 },
+	{ 0x03D9, 0x0172 },
+	{ 0x03DD, 0x0168 },
+	{ 0x03DE, 0x016A },
+	{ 0x03E0, 0x0101 },
+	{ 0x03E7, 0x012F },
+	{ 0x03EC, 0x0117 },
+	{ 0x03EF, 0x012B },
+	{ 0x03F1, 0x0146 },
+	{ 0x03F2, 0x014D },
+	{ 0x03F3, 0x0137 },
+	{ 0x03F9, 0x0173 },
+	{ 0x03FD, 0x0169 },
+	{ 0x03FE, 0x016B },
+	{ 0x047E, 0x203E },
+	{ 0x04A1, 0x3002 },
+	{ 0x04A2, 0x300C },
+	{ 0x04A3, 0x300D },
+	{ 0x04A4, 0x3001 },
+	{ 0x04A5, 0x30FB },
+	{ 0x04A6, 0x30F2 },
+	{ 0x04A7, 0x30A1 },
+	{ 0x04A8, 0x30A3 },
+	{ 0x04A9, 0x30A5 },
+	{ 0x04AA, 0x30A7 },
+	{ 0x04AB, 0x30A9 },
+	{ 0x04AC, 0x30E3 },
+	{ 0x04AD, 0x30E5 },
+	{ 0x04AE, 0x30E7 },
+	{ 0x04AF, 0x30C3 },
+	{ 0x04B0, 0x30FC },
+	{ 0x04B1, 0x30A2 },
+	{ 0x04B2, 0x30A4 },
+	{ 0x04B3, 0x30A6 },
+	{ 0x04B4, 0x30A8 },
+	{ 0x04B5, 0x30AA },
+	{ 0x04B6, 0x30AB },
+	{ 0x04B7, 0x30AD },
+	{ 0x04B8, 0x30AF },
+	{ 0x04B9, 0x30B1 },
+	{ 0x04BA, 0x30B3 },
+	{ 0x04BB, 0x30B5 },
+	{ 0x04BC, 0x30B7 },
+	{ 0x04BD, 0x30B9 },
+	{ 0x04BE, 0x30BB },
+	{ 0x04BF, 0x30BD },
+	{ 0x04C0, 0x30BF },
+	{ 0x04C1, 0x30C1 },
+	{ 0x04C2, 0x30C4 },
+	{ 0x04C3, 0x30C6 },
+	{ 0x04C4, 0x30C8 },
+	{ 0x04C5, 0x30CA },
+	{ 0x04C6, 0x30CB },
+	{ 0x04C7, 0x30CC },
+	{ 0x04C8, 0x30CD },
+	{ 0x04C9, 0x30CE },
+	{ 0x04CA, 0x30CF },
+	{ 0x04CB, 0x30D2 },
+	{ 0x04CC, 0x30D5 },
+	{ 0x04CD, 0x30D8 },
+	{ 0x04CE, 0x30DB },
+	{ 0x04CF, 0x30DE },
+	{ 0x04D0, 0x30DF },
+	{ 0x04D1, 0x30E0 },
+	{ 0x04D2, 0x30E1 },
+	{ 0x04D3, 0x30E2 },
+	{ 0x04D4, 0x30E4 },
+	{ 0x04D5, 0x30E6 },
+	{ 0x04D6, 0x30E8 },
+	{ 0x04D7, 0x30E9 },
+	{ 0x04D8, 0x30EA },
+	{ 0x04D9, 0x30EB },
+	{ 0x04DA, 0x30EC },
+	{ 0x04DB, 0x30ED },
+	{ 0x04DC, 0x30EF },
+	{ 0x04DD, 0x30F3 },
+	{ 0x04DE, 0x309B },
+	{ 0x04DF, 0x309C },
+	{ 0x05AC, 0x060C },
+	{ 0x05BB, 0x061B },
+	{ 0x05BF, 0x061F },
+	{ 0x05C1, 0x0621 },
+	{ 0x05C2, 0x0622 },
+	{ 0x05C3, 0x0623 },
+	{ 0x05C4, 0x0624 },
+	{ 0x05C5, 0x0625 },
+	{ 0x05C6, 0x0626 },
+	{ 0x05C7, 0x0627 },
+	{ 0x05C8, 0x0628 },
+	{ 0x05C9, 0x0629 },
+	{ 0x05CA, 0x062A },
+	{ 0x05CB, 0x062B },
+	{ 0x05CC, 0x062C },
+	{ 0x05CD, 0x062D },
+	{ 0x05CE, 0x062E },
+	{ 0x05CF, 0x062F },
+	{ 0x05D0, 0x0630 },
+	{ 0x05D1, 0x0631 },
+	{ 0x05D2, 0x0632 },
+	{ 0x05D3, 0x0633 },
+	{ 0x05D4, 0x0634 },
+	{ 0x05D5, 0x0635 },
+	{ 0x05D6, 0x0636 },
+	{ 0x05D7, 0x0637 },
+	{ 0x05D8, 0x0638 },
+	{ 0x05D9, 0x0639 },
+	{ 0x05DA, 0x063A },
+	{ 0x05E0, 0x0640 },
+	{ 0x05E1, 0x0641 },
+	{ 0x05E2, 0x0642 },
+	{ 0x05E3, 0x0643 },
+	{ 0x05E4, 0x0644 },
+	{ 0x05E5, 0x0645 },
+	{ 0x05E6, 0x0646 },
+	{ 0x05E7, 0x0647 },
+	{ 0x05E8, 0x0648 },
+	{ 0x05E9, 0x0649 },
+	{ 0x05EA, 0x064A },
+	{ 0x05EB, 0x064B },
+	{ 0x05EC, 0x064C },
+	{ 0x05ED, 0x064D },
+	{ 0x05EE, 0x064E },
+	{ 0x05EF, 0x064F },
+	{ 0x05F0, 0x0650 },
+	{ 0x05F1, 0x0651 },
+	{ 0x05F2, 0x0652 },
+	{ 0x06A1, 0x0452 },
+	{ 0x06A2, 0x0453 },
+	{ 0x06A3, 0x0451 },
+	{ 0x06A4, 0x0454 },
+	{ 0x06A5, 0x0455 },
+	{ 0x06A6, 0x0456 },
+	{ 0x06A7, 0x0457 },
+	{ 0x06A8, 0x0458 },
+	{ 0x06A9, 0x0459 },
+	{ 0x06AA, 0x045A },
+	{ 0x06AB, 0x045B },
+	{ 0x06AC, 0x045C },
+	{ 0x06AE, 0x045E },
+	{ 0x06AF, 0x045F },
+	{ 0x06B0, 0x2116 },
+	{ 0x06B1, 0x0402 },
+	{ 0x06B2, 0x0403 },
+	{ 0x06B3, 0x0401 },
+	{ 0x06B4, 0x0404 },
+	{ 0x06B5, 0x0405 },
+	{ 0x06B6, 0x0406 },
+	{ 0x06B7, 0x0407 },
+	{ 0x06B8, 0x0408 },
+	{ 0x06B9, 0x0409 },
+	{ 0x06BA, 0x040A },
+	{ 0x06BB, 0x040B },
+	{ 0x06BC, 0x040C },
+	{ 0x06BE, 0x040E },
+	{ 0x06BF, 0x040F },
+	{ 0x06C0, 0x044E },
+	{ 0x06C1, 0x0430 },
+	{ 0x06C2, 0x0431 },
+	{ 0x06C3, 0x0446 },
+	{ 0x06C4, 0x0434 },
+	{ 0x06C5, 0x0435 },
+	{ 0x06C6, 0x0444 },
+	{ 0x06C7, 0x0433 },
+	{ 0x06C8, 0x0445 },
+	{ 0x06C9, 0x0438 },
+	{ 0x06CA, 0x0439 },
+	{ 0x06CB, 0x043A },
+	{ 0x06CC, 0x043B },
+	{ 0x06CD, 0x043C },
+	{ 0x06CE, 0x043D },
+	{ 0x06CF, 0x043E },
+	{ 0x06D0, 0x043F },
+	{ 0x06D1, 0x044F },
+	{ 0x06D2, 0x0440 },
+	{ 0x06D3, 0x0441 },
+	{ 0x06D4, 0x0442 },
+	{ 0x06D5, 0x0443 },
+	{ 0x06D6, 0x0436 },
+	{ 0x06D7, 0x0432 },
+	{ 0x06D8, 0x044C },
+	{ 0x06D9, 0x044B },
+	{ 0x06DA, 0x0437 },
+	{ 0x06DB, 0x0448 },
+	{ 0x06DC, 0x044D },
+	{ 0x06DD, 0x0449 },
+	{ 0x06DE, 0x0447 },
+	{ 0x06DF, 0x044A },
+	{ 0x06E0, 0x042E },
+	{ 0x06E1, 0x0410 },
+	{ 0x06E2, 0x0411 },
+	{ 0x06E3, 0x0426 },
+	{ 0x06E4, 0x0414 },
+	{ 0x06E5, 0x0415 },
+	{ 0x06E6, 0x0424 },
+	{ 0x06E7, 0x0413 },
+	{ 0x06E8, 0x0425 },
+	{ 0x06E9, 0x0418 },
+	{ 0x06EA, 0x0419 },
+	{ 0x06EB, 0x041A },
+	{ 0x06EC, 0x041B },
+	{ 0x06ED, 0x041C },
+	{ 0x06EE, 0x041D },
+	{ 0x06EF, 0x041E },
+	{ 0x06F0, 0x041F },
+	{ 0x06F1, 0x042F },
+	{ 0x06F2, 0x0420 },
+	{ 0x06F3, 0x0421 },
+	{ 0x06F4, 0x0422 },
+	{ 0x06F5, 0x0423 },
+	{ 0x06F6, 0x0416 },
+	{ 0x06F7, 0x0412 },
+	{ 0x06F8, 0x042C },
+	{ 0x06F9, 0x042B },
+	{ 0x06FA, 0x0417 },
+	{ 0x06FB, 0x0428 },
+	{ 0x06FC, 0x042D },
+	{ 0x06FD, 0x0429 },
+	{ 0x06FE, 0x0427 },
+	{ 0x06FF, 0x042A },
+	{ 0x07A1, 0x0386 },
+	{ 0x07A2, 0x0388 },
+	{ 0x07A3, 0x0389 },
+	{ 0x07A4, 0x038A },
+	{ 0x07A5, 0x03AA },
+	{ 0x07A7, 0x038C },
+	{ 0x07A8, 0x038E },
+	{ 0x07A9, 0x03AB },
+	{ 0x07AB, 0x038F },
+	{ 0x07AE, 0x0385 },
+	{ 0x07AF, 0x2015 },
+	{ 0x07B1, 0x03AC },
+	{ 0x07B2, 0x03AD },
+	{ 0x07B3, 0x03AE },
+	{ 0x07B4, 0x03AF },
+	{ 0x07B5, 0x03CA },
+	{ 0x07B6, 0x0390 },
+	{ 0x07B7, 0x03CC },
+	{ 0x07B8, 0x03CD },
+	{ 0x07B9, 0x03CB },
+	{ 0x07BA, 0x03B0 },
+	{ 0x07BB, 0x03CE },
+	{ 0x07C1, 0x0391 },
+	{ 0x07C2, 0x0392 },
+	{ 0x07C3, 0x0393 },
+	{ 0x07C4, 0x0394 },
+	{ 0x07C5, 0x0395 },
+	{ 0x07C6, 0x0396 },
+	{ 0x07C7, 0x0397 },
+	{ 0x07C8, 0x0398 },
+	{ 0x07C9, 0x0399 },
+	{ 0x07CA, 0x039A },
+	{ 0x07CB, 0x039B },
+	{ 0x07CC, 0x039C },
+	{ 0x07CD, 0x039D },
+	{ 0x07CE, 0x039E },
+	{ 0x07CF, 0x039F },
+	{ 0x07D0, 0x03A0 },
+	{ 0x07D1, 0x03A1 },
+	{ 0x07D2, 0x03A3 },
+	{ 0x07D4, 0x03A4 },
+	{ 0x07D5, 0x03A5 },
+	{ 0x07D6, 0x03A6 },
+	{ 0x07D7, 0x03A7 },
+	{ 0x07D8, 0x03A8 },
+	{ 0x07D9, 0x03A9 },
+	{ 0x07E1, 0x03B1 },
+	{ 0x07E2, 0x03B2 },
+	{ 0x07E3, 0x03B3 },
+	{ 0x07E4, 0x03B4 },
+	{ 0x07E5, 0x03B5 },
+	{ 0x07E6, 0x03B6 },
+	{ 0x07E7, 0x03B7 },
+	{ 0x07E8, 0x03B8 },
+	{ 0x07E9, 0x03B9 },
+	{ 0x07EA, 0x03BA },
+	{ 0x07EB, 0x03BB },
+	{ 0x07EC, 0x03BC },
+	{ 0x07ED, 0x03BD },
+	{ 0x07EE, 0x03BE },
+	{ 0x07EF, 0x03BF },
+	{ 0x07F0, 0x03C0 },
+	{ 0x07F1, 0x03C1 },
+	{ 0x07F2, 0x03C3 },
+	{ 0x07F3, 0x03C2 },
+	{ 0x07F4, 0x03C4 },
+	{ 0x07F5, 0x03C5 },
+	{ 0x07F6, 0x03C6 },
+	{ 0x07F7, 0x03C7 },
+	{ 0x07F8, 0x03C8 },
+	{ 0x07F9, 0x03C9 },
+	{ 0x08A1, 0x23B7 },
+	{ 0x08A2, 0x250C },
+	{ 0x08A3, 0x2500 },
+	{ 0x08A4, 0x2320 },
+	{ 0x08A5, 0x2321 },
+	{ 0x08A6, 0x2502 },
+	{ 0x08A7, 0x23A1 },
+	{ 0x08A8, 0x23A3 },
+	{ 0x08A9, 0x23A4 },
+	{ 0x08AA, 0x23A6 },
+	{ 0x08AB, 0x239B },
+	{ 0x08AC, 0x239D },
+	{ 0x08AD, 0x239E },
+	{ 0x08AE, 0x23A0 },
+	{ 0x08AF, 0x23A8 },
+	{ 0x08B0, 0x23AC },
+	{ 0x08BC, 0x2264 },
+	{ 0x08BD, 0x2260 },
+	{ 0x08BE, 0x2265 },
+	{ 0x08BF, 0x222B },
+	{ 0x08C0, 0x2234 },
+	{ 0x08C1, 0x221D },
+	{ 0x08C2, 0x221E },
+	{ 0x08C5, 0x2207 },
+	{ 0x08C8, 0x223C },
+	{ 0x08C9, 0x2243 },
+	{ 0x08CD, 0x21D4 },
+	{ 0x08CE, 0x21D2 },
+	{ 0x08CF, 0x2261 },
+	{ 0x08D6, 0x221A },
+	{ 0x08DA, 0x2282 },
+	{ 0x08DB, 0x2283 },
+	{ 0x08DC, 0x2229 },
+	{ 0x08DD, 0x222A },
+	{ 0x08DE, 0x2227 },
+	{ 0x08DF, 0x2228 },
+	{ 0x08EF, 0x2202 },
+	{ 0x08F6, 0x0192 },
+	{ 0x08FB, 0x2190 },
+	{ 0x08FC, 0x2191 },
+	{ 0x08FD, 0x2192 },
+	{ 0x08FE, 0x2193 },
+	{ 0x09E0, 0x25C6 },
+	{ 0x09E1, 0x2592 },
+	{ 0x09E2, 0x2409 },
+	{ 0x09E3, 0x240C },
+	{ 0x09E4, 0x240D },
+	{ 0x09E5, 0x240A },
+	{ 0x09E8, 0x2424 },
+	{ 0x09E9, 0x240B },
+	{ 0x09EA, 0x2518 },
+	{ 0x09EB, 0x2510 },
+	{ 0x09EC, 0x250C },
+	{ 0x09ED, 0x2514 },
+	{ 0x09EE, 0x253C },
+	{ 0x09EF, 0x23BA },
+	{ 0x09F0, 0x23BB },
+	{ 0x09F1, 0x2500 },
+	{ 0x09F2, 0x23BC },
+	{ 0x09F3, 0x23BD },
+	{ 0x09F4, 0x251C },
+	{ 0x09F5, 0x2524 },
+	{ 0x09F6, 0x2534 },
+	{ 0x09F7, 0x252C },
+	{ 0x09F8, 0x2502 },
+	{ 0x0AA1, 0x2003 },
+	{ 0x0AA2, 0x2002 },
+	{ 0x0AA3, 0x2004 },
+	{ 0x0AA4, 0x2005 },
+	{ 0x0AA5, 0x2007 },
+	{ 0x0AA6, 0x2008 },
+	{ 0x0AA7, 0x2009 },
+	{ 0x0AA8, 0x200A },
+	{ 0x0AA9, 0x2014 },
+	{ 0x0AAA, 0x2013 },
+	{ 0x0AAE, 0x2026 },
+	{ 0x0AAF, 0x2025 },
+	{ 0x0AB0, 0x2153 },
+	{ 0x0AB1, 0x2154 },
+	{ 0x0AB2, 0x2155 },
+	{ 0x0AB3, 0x2156 },
+	{ 0x0AB4, 0x2157 },
+	{ 0x0AB5, 0x2158 },
+	{ 0x0AB6, 0x2159 },
+	{ 0x0AB7, 0x215A },
+	{ 0x0AB8, 0x2105 },
+	{ 0x0ABB, 0x2012 },
+	{ 0x0ABC, 0x2329 },
+	{ 0x0ABE, 0x232A },
+	{ 0x0AC3, 0x215B },
+	{ 0x0AC4, 0x215C },
+	{ 0x0AC5, 0x215D },
+	{ 0x0AC6, 0x215E },
+	{ 0x0AC9, 0x2122 },
+	{ 0x0ACA, 0x2613 },
+	{ 0x0ACC, 0x25C1 },
+	{ 0x0ACD, 0x25B7 },
+	{ 0x0ACE, 0x25CB },
+	{ 0x0ACF, 0x25AF },
+	{ 0x0AD0, 0x2018 },
+	{ 0x0AD1, 0x2019 },
+	{ 0x0AD2, 0x201C },
+	{ 0x0AD3, 0x201D },
+	{ 0x0AD4, 0x211E },
+	{ 0x0AD6, 0x2032 },
+	{ 0x0AD7, 0x2033 },
+	{ 0x0AD9, 0x271D },
+	{ 0x0ADB, 0x25AC },
+	{ 0x0ADC, 0x25C0 },
+	{ 0x0ADD, 0x25B6 },
+	{ 0x0ADE, 0x25CF },
+	{ 0x0ADF, 0x25AE },
+	{ 0x0AE0, 0x25E6 },
+	{ 0x0AE1, 0x25AB },
+	{ 0x0AE2, 0x25AD },
+	{ 0x0AE3, 0x25B3 },
+	{ 0x0AE4, 0x25BD },
+	{ 0x0AE5, 0x2606 },
+	{ 0x0AE6, 0x2022 },
+	{ 0x0AE7, 0x25AA },
+	{ 0x0AE8, 0x25B2 },
+	{ 0x0AE9, 0x25BC },
+	{ 0x0AEA, 0x261C },
+	{ 0x0AEB, 0x261E },
+	{ 0x0AEC, 0x2663 },
+	{ 0x0AED, 0x2666 },
+	{ 0x0AEE, 0x2665 },
+	{ 0x0AF0, 0x2720 },
+	{ 0x0AF1, 0x2020 },
+	{ 0x0AF2, 0x2021 },
+	{ 0x0AF3, 0x2713 },
+	{ 0x0AF4, 0x2717 },
+	{ 0x0AF5, 0x266F },
+	{ 0x0AF6, 0x266D },
+	{ 0x0AF7, 0x2642 },
+	{ 0x0AF8, 0x2640 },
+	{ 0x0AF9, 0x260E },
+	{ 0x0AFA, 0x2315 },
+	{ 0x0AFB, 0x2117 },
+	{ 0x0AFC, 0x2038 },
+	{ 0x0AFD, 0x201A },
+	{ 0x0AFE, 0x201E },
+	{ 0x0BA3, 0x003C },
+	{ 0x0BA6, 0x003E },
+	{ 0x0BA8, 0x2228 },
+	{ 0x0BA9, 0x2227 },
+	{ 0x0BC0, 0x00AF },
+	{ 0x0BC2, 0x22A5 },
+	{ 0x0BC3, 0x2229 },
+	{ 0x0BC4, 0x230A },
+	{ 0x0BC6, 0x005F },
+	{ 0x0BCA, 0x2218 },
+	{ 0x0BCC, 0x2395 },
+	{ 0x0BCE, 0x22A4 },
+	{ 0x0BCF, 0x25CB },
+	{ 0x0BD3, 0x2308 },
+	{ 0x0BD6, 0x222A },
+	{ 0x0BD8, 0x2283 },
+	{ 0x0BDA, 0x2282 },
+	{ 0x0BDC, 0x22A2 },
+	{ 0x0BFC, 0x22A3 },
+	{ 0x0CDF, 0x2017 },
+	{ 0x0CE0, 0x05D0 },
+	{ 0x0CE1, 0x05D1 },
+	{ 0x0CE2, 0x05D2 },
+	{ 0x0CE3, 0x05D3 },
+	{ 0x0CE4, 0x05D4 },
+	{ 0x0CE5, 0x05D5 },
+	{ 0x0CE6, 0x05D6 },
+	{ 0x0CE7, 0x05D7 },
+	{ 0x0CE8, 0x05D8 },
+	{ 0x0CE9, 0x05D9 },
+	{ 0x0CEA, 0x05DA },
+	{ 0x0CEB, 0x05DB },
+	{ 0x0CEC, 0x05DC },
+	{ 0x0CED, 0x05DD },
+	{ 0x0CEE, 0x05DE },
+	{ 0x0CEF, 0x05DF },
+	{ 0x0CF0, 0x05E0 },
+	{ 0x0CF1, 0x05E1 },
+	{ 0x0CF2, 0x05E2 },
+	{ 0x0CF3, 0x05E3 },
+	{ 0x0CF4, 0x05E4 },
+	{ 0x0CF5, 0x05E5 },
+	{ 0x0CF6, 0x05E6 },
+	{ 0x0CF7, 0x05E7 },
+	{ 0x0CF8, 0x05E8 },
+	{ 0x0CF9, 0x05E9 },
+	{ 0x0CFA, 0x05EA },
+	{ 0x0DA1, 0x0E01 },
+	{ 0x0DA2, 0x0E02 },
+	{ 0x0DA3, 0x0E03 },
+	{ 0x0DA4, 0x0E04 },
+	{ 0x0DA5, 0x0E05 },
+	{ 0x0DA6, 0x0E06 },
+	{ 0x0DA7, 0x0E07 },
+	{ 0x0DA8, 0x0E08 },
+	{ 0x0DA9, 0x0E09 },
+	{ 0x0DAA, 0x0E0A },
+	{ 0x0DAB, 0x0E0B },
+	{ 0x0DAC, 0x0E0C },
+	{ 0x0DAD, 0x0E0D },
+	{ 0x0DAE, 0x0E0E },
+	{ 0x0DAF, 0x0E0F },
+	{ 0x0DB0, 0x0E10 },
+	{ 0x0DB1, 0x0E11 },
+	{ 0x0DB2, 0x0E12 },
+	{ 0x0DB3, 0x0E13 },
+	{ 0x0DB4, 0x0E14 },
+	{ 0x0DB5, 0x0E15 },
+	{ 0x0DB6, 0x0E16 },
+	{ 0x0DB7, 0x0E17 },
+	{ 0x0DB8, 0x0E18 },
+	{ 0x0DB9, 0x0E19 },
+	{ 0x0DBA, 0x0E1A },
+	{ 0x0DBB, 0x0E1B },
+	{ 0x0DBC, 0x0E1C },
+	{ 0x0DBD, 0x0E1D },
+	{ 0x0DBE, 0x0E1E },
+	{ 0x0DBF, 0x0E1F },
+	{ 0x0DC0, 0x0E20 },
+	{ 0x0DC1, 0x0E21 },
+	{ 0x0DC2, 0x0E22 },
+	{ 0x0DC3, 0x0E23 },
+	{ 0x0DC4, 0x0E24 },
+	{ 0x0DC5, 0x0E25 },
+	{ 0x0DC6, 0x0E26 },
+	{ 0x0DC7, 0x0E27 },
+	{ 0x0DC8, 0x0E28 },
+	{ 0x0DC9, 0x0E29 },
+	{ 0x0DCA, 0x0E2A },
+	{ 0x0DCB, 0x0E2B },
+	{ 0x0DCC, 0x0E2C },
+	{ 0x0DCD, 0x0E2D },
+	{ 0x0DCE, 0x0E2E },
+	{ 0x0DCF, 0x0E2F },
+	{ 0x0DD0, 0x0E30 },
+	{ 0x0DD1, 0x0E31 },
+	{ 0x0DD2, 0x0E32 },
+	{ 0x0DD3, 0x0E33 },
+	{ 0x0DD4, 0x0E34 },
+	{ 0x0DD5, 0x0E35 },
+	{ 0x0DD6, 0x0E36 },
+	{ 0x0DD7, 0x0E37 },
+	{ 0x0DD8, 0x0E38 },
+	{ 0x0DD9, 0x0E39 },
+	{ 0x0DDA, 0x0E3A },
+	{ 0x0DDF, 0x0E3F },
+	{ 0x0DE0, 0x0E40 },
+	{ 0x0DE1, 0x0E41 },
+	{ 0x0DE2, 0x0E42 },
+	{ 0x0DE3, 0x0E43 },
+	{ 0x0DE4, 0x0E44 },
+	{ 0x0DE5, 0x0E45 },
+	{ 0x0DE6, 0x0E46 },
+	{ 0x0DE7, 0x0E47 },
+	{ 0x0DE8, 0x0E48 },
+	{ 0x0DE9, 0x0E49 },
+	{ 0x0DEA, 0x0E4A },
+	{ 0x0DEB, 0x0E4B },
+	{ 0x0DEC, 0x0E4C },
+	{ 0x0DED, 0x0E4D },
+	{ 0x0DF0, 0x0E50 },
+	{ 0x0DF1, 0x0E51 },
+	{ 0x0DF2, 0x0E52 },
+	{ 0x0DF3, 0x0E53 },
+	{ 0x0DF4, 0x0E54 },
+	{ 0x0DF5, 0x0E55 },
+	{ 0x0DF6, 0x0E56 },
+	{ 0x0DF7, 0x0E57 },
+	{ 0x0DF8, 0x0E58 },
+	{ 0x0DF9, 0x0E59 },
+	{ 0x0EA1, 0x3131 },
+	{ 0x0EA2, 0x3132 },
+	{ 0x0EA3, 0x3133 },
+	{ 0x0EA4, 0x3134 },
+	{ 0x0EA5, 0x3135 },
+	{ 0x0EA6, 0x3136 },
+	{ 0x0EA7, 0x3137 },
+	{ 0x0EA8, 0x3138 },
+	{ 0x0EA9, 0x3139 },
+	{ 0x0EAA, 0x313A },
+	{ 0x0EAB, 0x313B },
+	{ 0x0EAC, 0x313C },
+	{ 0x0EAD, 0x313D },
+	{ 0x0EAE, 0x313E },
+	{ 0x0EAF, 0x313F },
+	{ 0x0EB0, 0x3140 },
+	{ 0x0EB1, 0x3141 },
+	{ 0x0EB2, 0x3142 },
+	{ 0x0EB3, 0x3143 },
+	{ 0x0EB4, 0x3144 },
+	{ 0x0EB5, 0x3145 },
+	{ 0x0EB6, 0x3146 },
+	{ 0x0EB7, 0x3147 },
+	{ 0x0EB8, 0x3148 },
+	{ 0x0EB9, 0x3149 },
+	{ 0x0EBA, 0x314A },
+	{ 0x0EBB, 0x314B },
+	{ 0x0EBC, 0x314C },
+	{ 0x0EBD, 0x314D },
+	{ 0x0EBE, 0x314E },
+	{ 0x0EBF, 0x314F },
+	{ 0x0EC0, 0x3150 },
+	{ 0x0EC1, 0x3151 },
+	{ 0x0EC2, 0x3152 },
+	{ 0x0EC3, 0x3153 },
+	{ 0x0EC4, 0x3154 },
+	{ 0x0EC5, 0x3155 },
+	{ 0x0EC6, 0x3156 },
+	{ 0x0EC7, 0x3157 },
+	{ 0x0EC8, 0x3158 },
+	{ 0x0EC9, 0x3159 },
+	{ 0x0ECA, 0x315A },
+	{ 0x0ECB, 0x315B },
+	{ 0x0ECC, 0x315C },
+	{ 0x0ECD, 0x315D },
+	{ 0x0ECE, 0x315E },
+	{ 0x0ECF, 0x315F },
+	{ 0x0ED0, 0x3160 },
+	{ 0x0ED1, 0x3161 },
+	{ 0x0ED2, 0x3162 },
+	{ 0x0ED3, 0x3163 },
+	{ 0x0ED4, 0x11A8 },
+	{ 0x0ED5, 0x11A9 },
+	{ 0x0ED6, 0x11AA },
+	{ 0x0ED7, 0x11AB },
+	{ 0x0ED8, 0x11AC },
+	{ 0x0ED9, 0x11AD },
+	{ 0x0EDA, 0x11AE },
+	{ 0x0EDB, 0x11AF },
+	{ 0x0EDC, 0x11B0 },
+	{ 0x0EDD, 0x11B1 },
+	{ 0x0EDE, 0x11B2 },
+	{ 0x0EDF, 0x11B3 },
+	{ 0x0EE0, 0x11B4 },
+	{ 0x0EE1, 0x11B5 },
+	{ 0x0EE2, 0x11B6 },
+	{ 0x0EE3, 0x11B7 },
+	{ 0x0EE4, 0x11B8 },
+	{ 0x0EE5, 0x11B9 },
+	{ 0x0EE6, 0x11BA },
+	{ 0x0EE7, 0x11BB },
+	{ 0x0EE8, 0x11BC },
+	{ 0x0EE9, 0x11BD },
+	{ 0x0EEA, 0x11BE },
+	{ 0x0EEB, 0x11BF },
+	{ 0x0EEC, 0x11C0 },
+	{ 0x0EED, 0x11C1 },
+	{ 0x0EEE, 0x11C2 },
+	{ 0x0EEF, 0x316D },
+	{ 0x0EF0, 0x3171 },
+	{ 0x0EF1, 0x3178 },
+	{ 0x0EF2, 0x317F },
+	{ 0x0EF3, 0x3181 },
+	{ 0x0EF4, 0x3184 },
+	{ 0x0EF5, 0x3186 },
+	{ 0x0EF6, 0x318D },
+	{ 0x0EF7, 0x318E },
+	{ 0x0EF8, 0x11EB },
+	{ 0x0EF9, 0x11F0 },
+	{ 0x0EFA, 0x11F9 },
+	{ 0x0EFF, 0x20A9 },
+	{ 0x13A4, 0x20AC },
+	{ 0x13BC, 0x0152 },
+	{ 0x13BD, 0x0153 },
+	{ 0x13BE, 0x0178 },
+	{ 0x20AC, 0x20AC },
+};
+
+unsigned int KeyMappingX11::get_unicode_from_keysym(KeySym p_keysym) {
+
+	/* Latin-1 */
+	if (p_keysym>=0x20 && p_keysym<=0x7e)
+		return p_keysym;
+	if (p_keysym>=0xa0 && p_keysym<=0xff)
+		return p_keysym;
+	// keypad to latin1 is easy
+	if (p_keysym>=0xffaa && p_keysym<=0xffb9)
+		return p_keysym-0xff80;
+
+	/* Unicode (may be present)*/
+
+	if((p_keysym&0xff000000)==0x01000000)
+		return p_keysym&0x00ffffff;
+
+	int middle,low=0,high=_KEYSYM_MAX-1;
+	do {
+		middle=(high+low)/2;
+		if ( _xkeysym_to_unicode[middle].keysym==p_keysym)
+			return _xkeysym_to_unicode[middle].unicode;
+		if ( _xkeysym_to_unicode[middle].keysym<=p_keysym )
+			low=middle+1;
+		else
+			high=middle-1;
+	} while (high>=low);
+
+	return 0;
+
+}
+
+struct _XTranslateUnicodePairReverse {
+
+	unsigned int unicode;
+	KeySym keysym;
+};
+
+enum {
+
+	_UNICODE_MAX=750
+};
+
+static _XTranslateUnicodePairReverse _unicode_to_xkeysym[_UNICODE_MAX] = {
+	{ 0x0ABD, 0x002E },
+	{ 0x0BA3, 0x003C },
+	{ 0x0BA6, 0x003E },
+	{ 0x0BC6, 0x005F },
+	{ 0x0BC0, 0x00AF },
+	{ 0x03C0, 0x0100 },
+	{ 0x03E0, 0x0101 },
+	{ 0x01C3, 0x0102 },
+	{ 0x01E3, 0x0103 },
+	{ 0x01A1, 0x0104 },
+	{ 0x01B1, 0x0105 },
+	{ 0x01C6, 0x0106 },
+	{ 0x01E6, 0x0107 },
+	{ 0x02C6, 0x0108 },
+	{ 0x02E6, 0x0109 },
+	{ 0x02C5, 0x010A },
+	{ 0x02E5, 0x010B },
+	{ 0x01C8, 0x010C },
+	{ 0x01E8, 0x010D },
+	{ 0x01CF, 0x010E },
+	{ 0x01EF, 0x010F },
+	{ 0x01D0, 0x0110 },
+	{ 0x01F0, 0x0111 },
+	{ 0x03AA, 0x0112 },
+	{ 0x03BA, 0x0113 },
+	{ 0x03CC, 0x0116 },
+	{ 0x03EC, 0x0117 },
+	{ 0x01CA, 0x0118 },
+	{ 0x01EA, 0x0119 },
+	{ 0x01CC, 0x011A },
+	{ 0x01EC, 0x011B },
+	{ 0x02D8, 0x011C },
+	{ 0x02F8, 0x011D },
+	{ 0x02AB, 0x011E },
+	{ 0x02BB, 0x011F },
+	{ 0x02D5, 0x0120 },
+	{ 0x02F5, 0x0121 },
+	{ 0x03AB, 0x0122 },
+	{ 0x03BB, 0x0123 },
+	{ 0x02A6, 0x0124 },
+	{ 0x02B6, 0x0125 },
+	{ 0x02A1, 0x0126 },
+	{ 0x02B1, 0x0127 },
+	{ 0x03A5, 0x0128 },
+	{ 0x03B5, 0x0129 },
+	{ 0x03CF, 0x012A },
+	{ 0x03EF, 0x012B },
+	{ 0x03C7, 0x012E },
+	{ 0x03E7, 0x012F },
+	{ 0x02A9, 0x0130 },
+	{ 0x02B9, 0x0131 },
+	{ 0x02AC, 0x0134 },
+	{ 0x02BC, 0x0135 },
+	{ 0x03D3, 0x0136 },
+	{ 0x03F3, 0x0137 },
+	{ 0x03A2, 0x0138 },
+	{ 0x01C5, 0x0139 },
+	{ 0x01E5, 0x013A },
+	{ 0x03A6, 0x013B },
+	{ 0x03B6, 0x013C },
+	{ 0x01A5, 0x013D },
+	{ 0x01B5, 0x013E },
+	{ 0x01A3, 0x0141 },
+	{ 0x01B3, 0x0142 },
+	{ 0x01D1, 0x0143 },
+	{ 0x01F1, 0x0144 },
+	{ 0x03D1, 0x0145 },
+	{ 0x03F1, 0x0146 },
+	{ 0x01D2, 0x0147 },
+	{ 0x01F2, 0x0148 },
+	{ 0x03BD, 0x014A },
+	{ 0x03BF, 0x014B },
+	{ 0x03D2, 0x014C },
+	{ 0x03F2, 0x014D },
+	{ 0x01D5, 0x0150 },
+	{ 0x01F5, 0x0151 },
+	{ 0x13BC, 0x0152 },
+	{ 0x13BD, 0x0153 },
+	{ 0x01C0, 0x0154 },
+	{ 0x01E0, 0x0155 },
+	{ 0x03A3, 0x0156 },
+	{ 0x03B3, 0x0157 },
+	{ 0x01D8, 0x0158 },
+	{ 0x01F8, 0x0159 },
+	{ 0x01A6, 0x015A },
+	{ 0x01B6, 0x015B },
+	{ 0x02DE, 0x015C },
+	{ 0x02FE, 0x015D },
+	{ 0x01AA, 0x015E },
+	{ 0x01BA, 0x015F },
+	{ 0x01A9, 0x0160 },
+	{ 0x01B9, 0x0161 },
+	{ 0x01DE, 0x0162 },
+	{ 0x01FE, 0x0163 },
+	{ 0x01AB, 0x0164 },
+	{ 0x01BB, 0x0165 },
+	{ 0x03AC, 0x0166 },
+	{ 0x03BC, 0x0167 },
+	{ 0x03DD, 0x0168 },
+	{ 0x03FD, 0x0169 },
+	{ 0x03DE, 0x016A },
+	{ 0x03FE, 0x016B },
+	{ 0x02DD, 0x016C },
+	{ 0x02FD, 0x016D },
+	{ 0x01D9, 0x016E },
+	{ 0x01F9, 0x016F },
+	{ 0x01DB, 0x0170 },
+	{ 0x01FB, 0x0171 },
+	{ 0x03D9, 0x0172 },
+	{ 0x03F9, 0x0173 },
+	{ 0x13BE, 0x0178 },
+	{ 0x01AC, 0x0179 },
+	{ 0x01BC, 0x017A },
+	{ 0x01AF, 0x017B },
+	{ 0x01BF, 0x017C },
+	{ 0x01AE, 0x017D },
+	{ 0x01BE, 0x017E },
+	{ 0x08F6, 0x0192 },
+	{ 0x01B7, 0x02C7 },
+	{ 0x01A2, 0x02D8 },
+	{ 0x01FF, 0x02D9 },
+	{ 0x01B2, 0x02DB },
+	{ 0x01BD, 0x02DD },
+	{ 0x07AE, 0x0385 },
+	{ 0x07A1, 0x0386 },
+	{ 0x07A2, 0x0388 },
+	{ 0x07A3, 0x0389 },
+	{ 0x07A4, 0x038A },
+	{ 0x07A7, 0x038C },
+	{ 0x07A8, 0x038E },
+	{ 0x07AB, 0x038F },
+	{ 0x07B6, 0x0390 },
+	{ 0x07C1, 0x0391 },
+	{ 0x07C2, 0x0392 },
+	{ 0x07C3, 0x0393 },
+	{ 0x07C4, 0x0394 },
+	{ 0x07C5, 0x0395 },
+	{ 0x07C6, 0x0396 },
+	{ 0x07C7, 0x0397 },
+	{ 0x07C8, 0x0398 },
+	{ 0x07C9, 0x0399 },
+	{ 0x07CA, 0x039A },
+	{ 0x07CB, 0x039B },
+	{ 0x07CC, 0x039C },
+	{ 0x07CD, 0x039D },
+	{ 0x07CE, 0x039E },
+	{ 0x07CF, 0x039F },
+	{ 0x07D0, 0x03A0 },
+	{ 0x07D1, 0x03A1 },
+	{ 0x07D2, 0x03A3 },
+	{ 0x07D4, 0x03A4 },
+	{ 0x07D5, 0x03A5 },
+	{ 0x07D6, 0x03A6 },
+	{ 0x07D7, 0x03A7 },
+	{ 0x07D8, 0x03A8 },
+	{ 0x07D9, 0x03A9 },
+	{ 0x07A5, 0x03AA },
+	{ 0x07A9, 0x03AB },
+	{ 0x07B1, 0x03AC },
+	{ 0x07B2, 0x03AD },
+	{ 0x07B3, 0x03AE },
+	{ 0x07B4, 0x03AF },
+	{ 0x07BA, 0x03B0 },
+	{ 0x07E1, 0x03B1 },
+	{ 0x07E2, 0x03B2 },
+	{ 0x07E3, 0x03B3 },
+	{ 0x07E4, 0x03B4 },
+	{ 0x07E5, 0x03B5 },
+	{ 0x07E6, 0x03B6 },
+	{ 0x07E7, 0x03B7 },
+	{ 0x07E8, 0x03B8 },
+	{ 0x07E9, 0x03B9 },
+	{ 0x07EA, 0x03BA },
+	{ 0x07EB, 0x03BB },
+	{ 0x07EC, 0x03BC },
+	{ 0x07ED, 0x03BD },
+	{ 0x07EE, 0x03BE },
+	{ 0x07EF, 0x03BF },
+	{ 0x07F0, 0x03C0 },
+	{ 0x07F1, 0x03C1 },
+	{ 0x07F3, 0x03C2 },
+	{ 0x07F2, 0x03C3 },
+	{ 0x07F4, 0x03C4 },
+	{ 0x07F5, 0x03C5 },
+	{ 0x07F6, 0x03C6 },
+	{ 0x07F7, 0x03C7 },
+	{ 0x07F8, 0x03C8 },
+	{ 0x07F9, 0x03C9 },
+	{ 0x07B5, 0x03CA },
+	{ 0x07B9, 0x03CB },
+	{ 0x07B7, 0x03CC },
+	{ 0x07B8, 0x03CD },
+	{ 0x07BB, 0x03CE },
+	{ 0x06B3, 0x0401 },
+	{ 0x06B1, 0x0402 },
+	{ 0x06B2, 0x0403 },
+	{ 0x06B4, 0x0404 },
+	{ 0x06B5, 0x0405 },
+	{ 0x06B6, 0x0406 },
+	{ 0x06B7, 0x0407 },
+	{ 0x06B8, 0x0408 },
+	{ 0x06B9, 0x0409 },
+	{ 0x06BA, 0x040A },
+	{ 0x06BB, 0x040B },
+	{ 0x06BC, 0x040C },
+	{ 0x06BE, 0x040E },
+	{ 0x06BF, 0x040F },
+	{ 0x06E1, 0x0410 },
+	{ 0x06E2, 0x0411 },
+	{ 0x06F7, 0x0412 },
+	{ 0x06E7, 0x0413 },
+	{ 0x06E4, 0x0414 },
+	{ 0x06E5, 0x0415 },
+	{ 0x06F6, 0x0416 },
+	{ 0x06FA, 0x0417 },
+	{ 0x06E9, 0x0418 },
+	{ 0x06EA, 0x0419 },
+	{ 0x06EB, 0x041A },
+	{ 0x06EC, 0x041B },
+	{ 0x06ED, 0x041C },
+	{ 0x06EE, 0x041D },
+	{ 0x06EF, 0x041E },
+	{ 0x06F0, 0x041F },
+	{ 0x06F2, 0x0420 },
+	{ 0x06F3, 0x0421 },
+	{ 0x06F4, 0x0422 },
+	{ 0x06F5, 0x0423 },
+	{ 0x06E6, 0x0424 },
+	{ 0x06E8, 0x0425 },
+	{ 0x06E3, 0x0426 },
+	{ 0x06FE, 0x0427 },
+	{ 0x06FB, 0x0428 },
+	{ 0x06FD, 0x0429 },
+	{ 0x06FF, 0x042A },
+	{ 0x06F9, 0x042B },
+	{ 0x06F8, 0x042C },
+	{ 0x06FC, 0x042D },
+	{ 0x06E0, 0x042E },
+	{ 0x06F1, 0x042F },
+	{ 0x06C1, 0x0430 },
+	{ 0x06C2, 0x0431 },
+	{ 0x06D7, 0x0432 },
+	{ 0x06C7, 0x0433 },
+	{ 0x06C4, 0x0434 },
+	{ 0x06C5, 0x0435 },
+	{ 0x06D6, 0x0436 },
+	{ 0x06DA, 0x0437 },
+	{ 0x06C9, 0x0438 },
+	{ 0x06CA, 0x0439 },
+	{ 0x06CB, 0x043A },
+	{ 0x06CC, 0x043B },
+	{ 0x06CD, 0x043C },
+	{ 0x06CE, 0x043D },
+	{ 0x06CF, 0x043E },
+	{ 0x06D0, 0x043F },
+	{ 0x06D2, 0x0440 },
+	{ 0x06D3, 0x0441 },
+	{ 0x06D4, 0x0442 },
+	{ 0x06D5, 0x0443 },
+	{ 0x06C6, 0x0444 },
+	{ 0x06C8, 0x0445 },
+	{ 0x06C3, 0x0446 },
+	{ 0x06DE, 0x0447 },
+	{ 0x06DB, 0x0448 },
+	{ 0x06DD, 0x0449 },
+	{ 0x06DF, 0x044A },
+	{ 0x06D9, 0x044B },
+	{ 0x06D8, 0x044C },
+	{ 0x06DC, 0x044D },
+	{ 0x06C0, 0x044E },
+	{ 0x06D1, 0x044F },
+	{ 0x06A3, 0x0451 },
+	{ 0x06A1, 0x0452 },
+	{ 0x06A2, 0x0453 },
+	{ 0x06A4, 0x0454 },
+	{ 0x06A5, 0x0455 },
+	{ 0x06A6, 0x0456 },
+	{ 0x06A7, 0x0457 },
+	{ 0x06A8, 0x0458 },
+	{ 0x06A9, 0x0459 },
+	{ 0x06AA, 0x045A },
+	{ 0x06AB, 0x045B },
+	{ 0x06AC, 0x045C },
+	{ 0x06AE, 0x045E },
+	{ 0x06AF, 0x045F },
+	{ 0x0CE0, 0x05D0 },
+	{ 0x0CE1, 0x05D1 },
+	{ 0x0CE2, 0x05D2 },
+	{ 0x0CE3, 0x05D3 },
+	{ 0x0CE4, 0x05D4 },
+	{ 0x0CE5, 0x05D5 },
+	{ 0x0CE6, 0x05D6 },
+	{ 0x0CE7, 0x05D7 },
+	{ 0x0CE8, 0x05D8 },
+	{ 0x0CE9, 0x05D9 },
+	{ 0x0CEA, 0x05DA },
+	{ 0x0CEB, 0x05DB },
+	{ 0x0CEC, 0x05DC },
+	{ 0x0CED, 0x05DD },
+	{ 0x0CEE, 0x05DE },
+	{ 0x0CEF, 0x05DF },
+	{ 0x0CF0, 0x05E0 },
+	{ 0x0CF1, 0x05E1 },
+	{ 0x0CF2, 0x05E2 },
+	{ 0x0CF3, 0x05E3 },
+	{ 0x0CF4, 0x05E4 },
+	{ 0x0CF5, 0x05E5 },
+	{ 0x0CF6, 0x05E6 },
+	{ 0x0CF7, 0x05E7 },
+	{ 0x0CF8, 0x05E8 },
+	{ 0x0CF9, 0x05E9 },
+	{ 0x0CFA, 0x05EA },
+	{ 0x05AC, 0x060C },
+	{ 0x05BB, 0x061B },
+	{ 0x05BF, 0x061F },
+	{ 0x05C1, 0x0621 },
+	{ 0x05C2, 0x0622 },
+	{ 0x05C3, 0x0623 },
+	{ 0x05C4, 0x0624 },
+	{ 0x05C5, 0x0625 },
+	{ 0x05C6, 0x0626 },
+	{ 0x05C7, 0x0627 },
+	{ 0x05C8, 0x0628 },
+	{ 0x05C9, 0x0629 },
+	{ 0x05CA, 0x062A },
+	{ 0x05CB, 0x062B },
+	{ 0x05CC, 0x062C },
+	{ 0x05CD, 0x062D },
+	{ 0x05CE, 0x062E },
+	{ 0x05CF, 0x062F },
+	{ 0x05D0, 0x0630 },
+	{ 0x05D1, 0x0631 },
+	{ 0x05D2, 0x0632 },
+	{ 0x05D3, 0x0633 },
+	{ 0x05D4, 0x0634 },
+	{ 0x05D5, 0x0635 },
+	{ 0x05D6, 0x0636 },
+	{ 0x05D7, 0x0637 },
+	{ 0x05D8, 0x0638 },
+	{ 0x05D9, 0x0639 },
+	{ 0x05DA, 0x063A },
+	{ 0x05E0, 0x0640 },
+	{ 0x05E1, 0x0641 },
+	{ 0x05E2, 0x0642 },
+	{ 0x05E3, 0x0643 },
+	{ 0x05E4, 0x0644 },
+	{ 0x05E5, 0x0645 },
+	{ 0x05E6, 0x0646 },
+	{ 0x05E7, 0x0647 },
+	{ 0x05E8, 0x0648 },
+	{ 0x05E9, 0x0649 },
+	{ 0x05EA, 0x064A },
+	{ 0x05EB, 0x064B },
+	{ 0x05EC, 0x064C },
+	{ 0x05ED, 0x064D },
+	{ 0x05EE, 0x064E },
+	{ 0x05EF, 0x064F },
+	{ 0x05F0, 0x0650 },
+	{ 0x05F1, 0x0651 },
+	{ 0x05F2, 0x0652 },
+	{ 0x0DA1, 0x0E01 },
+	{ 0x0DA2, 0x0E02 },
+	{ 0x0DA3, 0x0E03 },
+	{ 0x0DA4, 0x0E04 },
+	{ 0x0DA5, 0x0E05 },
+	{ 0x0DA6, 0x0E06 },
+	{ 0x0DA7, 0x0E07 },
+	{ 0x0DA8, 0x0E08 },
+	{ 0x0DA9, 0x0E09 },
+	{ 0x0DAA, 0x0E0A },
+	{ 0x0DAB, 0x0E0B },
+	{ 0x0DAC, 0x0E0C },
+	{ 0x0DAD, 0x0E0D },
+	{ 0x0DAE, 0x0E0E },
+	{ 0x0DAF, 0x0E0F },
+	{ 0x0DB0, 0x0E10 },
+	{ 0x0DB1, 0x0E11 },
+	{ 0x0DB2, 0x0E12 },
+	{ 0x0DB3, 0x0E13 },
+	{ 0x0DB4, 0x0E14 },
+	{ 0x0DB5, 0x0E15 },
+	{ 0x0DB6, 0x0E16 },
+	{ 0x0DB7, 0x0E17 },
+	{ 0x0DB8, 0x0E18 },
+	{ 0x0DB9, 0x0E19 },
+	{ 0x0DBA, 0x0E1A },
+	{ 0x0DBB, 0x0E1B },
+	{ 0x0DBC, 0x0E1C },
+	{ 0x0DBD, 0x0E1D },
+	{ 0x0DBE, 0x0E1E },
+	{ 0x0DBF, 0x0E1F },
+	{ 0x0DC0, 0x0E20 },
+	{ 0x0DC1, 0x0E21 },
+	{ 0x0DC2, 0x0E22 },
+	{ 0x0DC3, 0x0E23 },
+	{ 0x0DC4, 0x0E24 },
+	{ 0x0DC5, 0x0E25 },
+	{ 0x0DC6, 0x0E26 },
+	{ 0x0DC7, 0x0E27 },
+	{ 0x0DC8, 0x0E28 },
+	{ 0x0DC9, 0x0E29 },
+	{ 0x0DCA, 0x0E2A },
+	{ 0x0DCB, 0x0E2B },
+	{ 0x0DCC, 0x0E2C },
+	{ 0x0DCD, 0x0E2D },
+	{ 0x0DCE, 0x0E2E },
+	{ 0x0DCF, 0x0E2F },
+	{ 0x0DD0, 0x0E30 },
+	{ 0x0DD1, 0x0E31 },
+	{ 0x0DD2, 0x0E32 },
+	{ 0x0DD3, 0x0E33 },
+	{ 0x0DD4, 0x0E34 },
+	{ 0x0DD5, 0x0E35 },
+	{ 0x0DD6, 0x0E36 },
+	{ 0x0DD7, 0x0E37 },
+	{ 0x0DD8, 0x0E38 },
+	{ 0x0DD9, 0x0E39 },
+	{ 0x0DDA, 0x0E3A },
+	{ 0x0DDF, 0x0E3F },
+	{ 0x0DE0, 0x0E40 },
+	{ 0x0DE1, 0x0E41 },
+	{ 0x0DE2, 0x0E42 },
+	{ 0x0DE3, 0x0E43 },
+	{ 0x0DE4, 0x0E44 },
+	{ 0x0DE5, 0x0E45 },
+	{ 0x0DE6, 0x0E46 },
+	{ 0x0DE7, 0x0E47 },
+	{ 0x0DE8, 0x0E48 },
+	{ 0x0DE9, 0x0E49 },
+	{ 0x0DEA, 0x0E4A },
+	{ 0x0DEB, 0x0E4B },
+	{ 0x0DEC, 0x0E4C },
+	{ 0x0DED, 0x0E4D },
+	{ 0x0DF0, 0x0E50 },
+	{ 0x0DF1, 0x0E51 },
+	{ 0x0DF2, 0x0E52 },
+	{ 0x0DF3, 0x0E53 },
+	{ 0x0DF4, 0x0E54 },
+	{ 0x0DF5, 0x0E55 },
+	{ 0x0DF6, 0x0E56 },
+	{ 0x0DF7, 0x0E57 },
+	{ 0x0DF8, 0x0E58 },
+	{ 0x0DF9, 0x0E59 },
+	{ 0x0ED4, 0x11A8 },
+	{ 0x0ED5, 0x11A9 },
+	{ 0x0ED6, 0x11AA },
+	{ 0x0ED7, 0x11AB },
+	{ 0x0ED8, 0x11AC },
+	{ 0x0ED9, 0x11AD },
+	{ 0x0EDA, 0x11AE },
+	{ 0x0EDB, 0x11AF },
+	{ 0x0EDC, 0x11B0 },
+	{ 0x0EDD, 0x11B1 },
+	{ 0x0EDE, 0x11B2 },
+	{ 0x0EDF, 0x11B3 },
+	{ 0x0EE0, 0x11B4 },
+	{ 0x0EE1, 0x11B5 },
+	{ 0x0EE2, 0x11B6 },
+	{ 0x0EE3, 0x11B7 },
+	{ 0x0EE4, 0x11B8 },
+	{ 0x0EE5, 0x11B9 },
+	{ 0x0EE6, 0x11BA },
+	{ 0x0EE7, 0x11BB },
+	{ 0x0EE8, 0x11BC },
+	{ 0x0EE9, 0x11BD },
+	{ 0x0EEA, 0x11BE },
+	{ 0x0EEB, 0x11BF },
+	{ 0x0EEC, 0x11C0 },
+	{ 0x0EED, 0x11C1 },
+	{ 0x0EEE, 0x11C2 },
+	{ 0x0EF8, 0x11EB },
+	{ 0x0EFA, 0x11F9 },
+	{ 0x0AA2, 0x2002 },
+	{ 0x0AA1, 0x2003 },
+	{ 0x0AA3, 0x2004 },
+	{ 0x0AA4, 0x2005 },
+	{ 0x0AA5, 0x2007 },
+	{ 0x0AA6, 0x2008 },
+	{ 0x0AA7, 0x2009 },
+	{ 0x0AA8, 0x200A },
+	{ 0x0ABB, 0x2012 },
+	{ 0x0AAA, 0x2013 },
+	{ 0x0AA9, 0x2014 },
+	{ 0x07AF, 0x2015 },
+	{ 0x0CDF, 0x2017 },
+	{ 0x0AD0, 0x2018 },
+	{ 0x0AD1, 0x2019 },
+	{ 0x0AFD, 0x201A },
+	{ 0x0AD2, 0x201C },
+	{ 0x0AD3, 0x201D },
+	{ 0x0AFE, 0x201E },
+	{ 0x0AF1, 0x2020 },
+	{ 0x0AF2, 0x2021 },
+	{ 0x0AE6, 0x2022 },
+	{ 0x0AAE, 0x2026 },
+	{ 0x0AD6, 0x2032 },
+	{ 0x0AD7, 0x2033 },
+	{ 0x0AFC, 0x2038 },
+	{ 0x047E, 0x203E },
+	{ 0x20A0, 0x20A0 },
+	{ 0x20A1, 0x20A1 },
+	{ 0x20A2, 0x20A2 },
+	{ 0x20A3, 0x20A3 },
+	{ 0x20A4, 0x20A4 },
+	{ 0x20A5, 0x20A5 },
+	{ 0x20A6, 0x20A6 },
+	{ 0x20A7, 0x20A7 },
+	{ 0x20A8, 0x20A8 },
+	{ 0x0EFF, 0x20A9 },
+	{ 0x20A9, 0x20A9 },
+	{ 0x20AA, 0x20AA },
+	{ 0x20AB, 0x20AB },
+	{ 0x20AC, 0x20AC },
+	{ 0x0AB8, 0x2105 },
+	{ 0x06B0, 0x2116 },
+	{ 0x0AFB, 0x2117 },
+	{ 0x0AD4, 0x211E },
+	{ 0x0AC9, 0x2122 },
+	{ 0x0AB0, 0x2153 },
+	{ 0x0AB1, 0x2154 },
+	{ 0x0AB2, 0x2155 },
+	{ 0x0AB3, 0x2156 },
+	{ 0x0AB4, 0x2157 },
+	{ 0x0AB5, 0x2158 },
+	{ 0x0AB6, 0x2159 },
+	{ 0x0AB7, 0x215A },
+	{ 0x0AC3, 0x215B },
+	{ 0x0AC4, 0x215C },
+	{ 0x0AC5, 0x215D },
+	{ 0x0AC6, 0x215E },
+	{ 0x08FB, 0x2190 },
+	{ 0x08FC, 0x2191 },
+	{ 0x08FD, 0x2192 },
+	{ 0x08FE, 0x2193 },
+	{ 0x08CE, 0x21D2 },
+	{ 0x08CD, 0x21D4 },
+	{ 0x08EF, 0x2202 },
+	{ 0x08C5, 0x2207 },
+	{ 0x0BCA, 0x2218 },
+	{ 0x08D6, 0x221A },
+	{ 0x08C1, 0x221D },
+	{ 0x08C2, 0x221E },
+	{ 0x08DE, 0x2227 },
+	{ 0x0BA9, 0x2227 },
+	{ 0x08DF, 0x2228 },
+	{ 0x0BA8, 0x2228 },
+	{ 0x08DC, 0x2229 },
+	{ 0x0BC3, 0x2229 },
+	{ 0x08DD, 0x222A },
+	{ 0x0BD6, 0x222A },
+	{ 0x08BF, 0x222B },
+	{ 0x08C0, 0x2234 },
+	{ 0x08C8, 0x2245 },
+	{ 0x08BD, 0x2260 },
+	{ 0x08CF, 0x2261 },
+	{ 0x08BC, 0x2264 },
+	{ 0x08BE, 0x2265 },
+	{ 0x08DA, 0x2282 },
+	{ 0x0BDA, 0x2282 },
+	{ 0x08DB, 0x2283 },
+	{ 0x0BD8, 0x2283 },
+	{ 0x0BFC, 0x22A2 },
+	{ 0x0BDC, 0x22A3 },
+	{ 0x0BC2, 0x22A4 },
+	{ 0x0BCE, 0x22A5 },
+	{ 0x0BD3, 0x2308 },
+	{ 0x0BC4, 0x230A },
+	{ 0x0AFA, 0x2315 },
+	{ 0x08A4, 0x2320 },
+	{ 0x08A5, 0x2321 },
+	{ 0x0ABC, 0x2329 },
+	{ 0x0ABE, 0x232A },
+	{ 0x0BCC, 0x2395 },
+	{ 0x09E2, 0x2409 },
+	{ 0x09E5, 0x240A },
+	{ 0x09E9, 0x240B },
+	{ 0x09E3, 0x240C },
+	{ 0x09E4, 0x240D },
+	{ 0x09DF, 0x2422 },
+	{ 0x09E8, 0x2424 },
+	{ 0x09F1, 0x2500 },
+	{ 0x08A6, 0x2502 },
+	{ 0x09F8, 0x2502 },
+	{ 0x09EC, 0x250C },
+	{ 0x09EB, 0x2510 },
+	{ 0x09ED, 0x2514 },
+	{ 0x09EA, 0x2518 },
+	{ 0x09F4, 0x251C },
+	{ 0x09F5, 0x2524 },
+	{ 0x09F7, 0x252C },
+	{ 0x09F6, 0x2534 },
+	{ 0x09EE, 0x253C },
+	{ 0x09E1, 0x2592 },
+	{ 0x0ADF, 0x25A0 },
+	{ 0x0ACF, 0x25A1 },
+	{ 0x0AE7, 0x25AA },
+	{ 0x0AE1, 0x25AB },
+	{ 0x0ADB, 0x25AC },
+	{ 0x0AE2, 0x25AD },
+	{ 0x0AE8, 0x25B2 },
+	{ 0x0AE3, 0x25B3 },
+	{ 0x0ADD, 0x25B6 },
+	{ 0x0ACD, 0x25B7 },
+	{ 0x0AE9, 0x25BC },
+	{ 0x0AE4, 0x25BD },
+	{ 0x0ADC, 0x25C0 },
+	{ 0x0ACC, 0x25C1 },
+	{ 0x09E0, 0x25C6 },
+	{ 0x0ACE, 0x25CB },
+	{ 0x0BCF, 0x25CB },
+	{ 0x0ADE, 0x25CF },
+	{ 0x0AE0, 0x25E6 },
+	{ 0x0AE5, 0x2606 },
+	{ 0x0AF9, 0x260E },
+	{ 0x0ACA, 0x2613 },
+	{ 0x0AEA, 0x261C },
+	{ 0x0AEB, 0x261E },
+	{ 0x0AF8, 0x2640 },
+	{ 0x0AF7, 0x2642 },
+	{ 0x0AEC, 0x2663 },
+	{ 0x0AEE, 0x2665 },
+	{ 0x0AED, 0x2666 },
+	{ 0x0AF6, 0x266D },
+	{ 0x0AF5, 0x266F },
+	{ 0x0AF3, 0x2713 },
+	{ 0x0AF4, 0x2717 },
+	{ 0x0AD9, 0x271D },
+	{ 0x0AF0, 0x2720 },
+	{ 0x04A4, 0x3001 },
+	{ 0x04A1, 0x3002 },
+	{ 0x04A2, 0x300C },
+	{ 0x04A3, 0x300D },
+	{ 0x04DE, 0x309B },
+	{ 0x04DF, 0x309C },
+	{ 0x04A7, 0x30A1 },
+	{ 0x04B1, 0x30A2 },
+	{ 0x04A8, 0x30A3 },
+	{ 0x04B2, 0x30A4 },
+	{ 0x04A9, 0x30A5 },
+	{ 0x04B3, 0x30A6 },
+	{ 0x04AA, 0x30A7 },
+	{ 0x04B4, 0x30A8 },
+	{ 0x04AB, 0x30A9 },
+	{ 0x04B5, 0x30AA },
+	{ 0x04B6, 0x30AB },
+	{ 0x04B7, 0x30AD },
+	{ 0x04B8, 0x30AF },
+	{ 0x04B9, 0x30B1 },
+	{ 0x04BA, 0x30B3 },
+	{ 0x04BB, 0x30B5 },
+	{ 0x04BC, 0x30B7 },
+	{ 0x04BD, 0x30B9 },
+	{ 0x04BE, 0x30BB },
+	{ 0x04BF, 0x30BD },
+	{ 0x04C0, 0x30BF },
+	{ 0x04C1, 0x30C1 },
+	{ 0x04AF, 0x30C3 },
+	{ 0x04C2, 0x30C4 },
+	{ 0x04C3, 0x30C6 },
+	{ 0x04C4, 0x30C8 },
+	{ 0x04C5, 0x30CA },
+	{ 0x04C6, 0x30CB },
+	{ 0x04C7, 0x30CC },
+	{ 0x04C8, 0x30CD },
+	{ 0x04C9, 0x30CE },
+	{ 0x04CA, 0x30CF },
+	{ 0x04CB, 0x30D2 },
+	{ 0x04CC, 0x30D5 },
+	{ 0x04CD, 0x30D8 },
+	{ 0x04CE, 0x30DB },
+	{ 0x04CF, 0x30DE },
+	{ 0x04D0, 0x30DF },
+	{ 0x04D1, 0x30E0 },
+	{ 0x04D2, 0x30E1 },
+	{ 0x04D3, 0x30E2 },
+	{ 0x04AC, 0x30E3 },
+	{ 0x04D4, 0x30E4 },
+	{ 0x04AD, 0x30E5 },
+	{ 0x04D5, 0x30E6 },
+	{ 0x04AE, 0x30E7 },
+	{ 0x04D6, 0x30E8 },
+	{ 0x04D7, 0x30E9 },
+	{ 0x04D8, 0x30EA },
+	{ 0x04D9, 0x30EB },
+	{ 0x04DA, 0x30EC },
+	{ 0x04DB, 0x30ED },
+	{ 0x04DC, 0x30EF },
+	{ 0x04A6, 0x30F2 },
+	{ 0x04DD, 0x30F3 },
+	{ 0x04A5, 0x30FB },
+	{ 0x04B0, 0x30FC },
+	{ 0x0EA1, 0x3131 },
+	{ 0x0EA2, 0x3132 },
+	{ 0x0EA3, 0x3133 },
+	{ 0x0EA4, 0x3134 },
+	{ 0x0EA5, 0x3135 },
+	{ 0x0EA6, 0x3136 },
+	{ 0x0EA7, 0x3137 },
+	{ 0x0EA8, 0x3138 },
+	{ 0x0EA9, 0x3139 },
+	{ 0x0EAA, 0x313A },
+	{ 0x0EAB, 0x313B },
+	{ 0x0EAC, 0x313C },
+	{ 0x0EAD, 0x313D },
+	{ 0x0EAE, 0x313E },
+	{ 0x0EAF, 0x313F },
+	{ 0x0EB0, 0x3140 },
+	{ 0x0EB1, 0x3141 },
+	{ 0x0EB2, 0x3142 },
+	{ 0x0EB3, 0x3143 },
+	{ 0x0EB4, 0x3144 },
+	{ 0x0EB5, 0x3145 },
+	{ 0x0EB6, 0x3146 },
+	{ 0x0EB7, 0x3147 },
+	{ 0x0EB8, 0x3148 },
+	{ 0x0EB9, 0x3149 },
+	{ 0x0EBA, 0x314A },
+	{ 0x0EBB, 0x314B },
+	{ 0x0EBC, 0x314C },
+	{ 0x0EBD, 0x314D },
+	{ 0x0EBE, 0x314E },
+	{ 0x0EBF, 0x314F },
+	{ 0x0EC0, 0x3150 },
+	{ 0x0EC1, 0x3151 },
+	{ 0x0EC2, 0x3152 },
+	{ 0x0EC3, 0x3153 },
+	{ 0x0EC4, 0x3154 },
+	{ 0x0EC5, 0x3155 },
+	{ 0x0EC6, 0x3156 },
+	{ 0x0EC7, 0x3157 },
+	{ 0x0EC8, 0x3158 },
+	{ 0x0EC9, 0x3159 },
+	{ 0x0ECA, 0x315A },
+	{ 0x0ECB, 0x315B },
+	{ 0x0ECC, 0x315C },
+	{ 0x0ECD, 0x315D },
+	{ 0x0ECE, 0x315E },
+	{ 0x0ECF, 0x315F },
+	{ 0x0ED0, 0x3160 },
+	{ 0x0ED1, 0x3161 },
+	{ 0x0ED2, 0x3162 },
+	{ 0x0ED3, 0x3163 },
+	{ 0x0EEF, 0x316D },
+	{ 0x0EF0, 0x3171 },
+	{ 0x0EF1, 0x3178 },
+	{ 0x0EF2, 0x317F },
+	{ 0x0EF4, 0x3184 },
+	{ 0x0EF5, 0x3186 },
+	{ 0x0EF6, 0x318D },
+	{ 0x0EF7, 0x318E }
+};
+
+KeySym KeyMappingX11::get_keysym_from_unicode(unsigned int p_unicode) {
+
+	/* Latin 1 */
+
+	if (p_unicode>=0x20 && p_unicode<=0x7e)
+		return p_unicode;
+
+	if (p_unicode>=0xa0 && p_unicode<=0xff)
+		return p_unicode;
+
+	int middle,low=0,high=_UNICODE_MAX-1;
+	do {
+		middle=(high+low)/2;
+		if ( _unicode_to_xkeysym[middle].keysym==p_unicode)
+			return _unicode_to_xkeysym[middle].keysym;
+		if ( _unicode_to_xkeysym[middle].keysym<=p_unicode )
+			low=middle+1;
+		else
+			high=middle-1;
+	} while (high>=low);
+
+	// if not found, let's hope X understands it as unicode
+	return p_unicode|0x01000000;
+}
diff --git a/platform/3ds/key_mapping_x11.h b/platform/3ds/key_mapping_x11.h
new file mode 100644
index 0000000..e3aede8
--- /dev/null
+++ b/platform/3ds/key_mapping_x11.h
@@ -0,0 +1,55 @@
+/*************************************************************************/
+/*  key_mapping_x11.h                                                    */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#ifndef KEY_MAPPING_X11_H
+#define KEY_MAPPING_X11_H
+
+/**
+	@author Juan Linietsky <reduzio@gmail.com>
+*/
+#include <X11/Xlib.h>
+#include <X11/XF86keysym.h>
+#define XK_MISCELLANY
+#define XK_LATIN1
+#define XK_XKB_KEYS
+#include <X11/keysymdef.h>
+
+#include "os/keyboard.h"
+
+class KeyMappingX11 {
+	KeyMappingX11() {};
+public:
+	static unsigned int get_keycode(KeySym p_keysym);
+	static KeySym get_keysym(unsigned int p_code);
+	static unsigned int get_unicode_from_keysym(KeySym p_keysym);
+	static KeySym get_keysym_from_unicode(unsigned int p_unicode);
+
+};
+
+
+#endif
diff --git a/platform/3ds/logo.png b/platform/3ds/logo.png
new file mode 100644
index 0000000000000000000000000000000000000000..4192ed1d1f51658d545c8e24e49395bf73bd4e8e
GIT binary patch
literal 1406
zcmV-^1%djBP)<h;3K|Lk000e1NJLTq001BW001Be1^@s6b9#F800006VoOIv0RI60
z0RN!9r;`8x010qNS#tmY3labT3lag+-G2N4000McNliru;0gg25eXVHijV*R1q(?;
zK~z}7wO3te990zl&bfE~b~oG1Cc8<~CMCr*m9$Mmn--+Bg8I@Q3ceVS<fT~qCIzh&
zK@e&ML8MPUiS$Y7t1Sq9Q53OAe?)Awh8js@T8gxUWOrwGW{wY;36p7dH%M~eFw5+n
z`+fJEbH8&h0T47cN<BH{6n!729I1I5VraCsB)A4(05GH990B?OY5?j0g2<`G;?_(c
z32p;$0AvAl1Ly~EAHX93<;cB6RMuqDz?0x6fHor94B!xe>oJhlx~jGQnuuN?qAdXO
z(RfZouPIJ50t7$-u$j3-DfJwHTgh=-w{Df)yLStK-<49klu{)CnJ8lan?N%EnuxN7
zVRSR|OHC#cB06svMjtcBQJ_}Q<|akAY=&VF5orKhT-U{c0|#K5Cc3)1Fg`wx;o;$U
z=wTwVlv45Psny)vY5)KtB4TDHB4c7=0v9e^K&e#1rAwEvZ{I$gJ$p7D+r!L8M3&b=
zf)g*P;TB+yNmOTNXYtkNAL9IkkIdp#ym$UxFfXs8PDBO(#Y-=#$<`*UQYg=u<2X=C
zfrv;%%1-%beERk*@|*Gq<q95uTf`SvFD@lmq*p0rhGA$hvkJqIT4_vE9ne}+E|-fl
zz`pO72Z|4n%>@9>W3gPo{QN^`{|Q{z1re1hmCAtD`l*N*kvPTbD2)WBA-j%_4sskv
zxvr}_Iy#K@_IB&H@=5vTyIq+1+sC81Di-q>vFF5fRI63=_xGb#tG%j}$`Fyo%tn)1
z0HQs<D!Ah~R45db<2YtMpU=6jyJ>1_>W$NHp4qeg;Az~N9zxIPM;I76iQe8mOixea
z+O=yCkpX7@k%%6LVOSTDpjiZ{$?Dm4U9+vNEn6rQ3R6>4M>{(^Ke=(^1_MB~T17US
zUH;(a&70W2e}BAf{<Lj--1q%|>h=0OfJ)Ra(mJzh3P@{BnM_7$tqsR<oP~vjo|&1M
z_m3Sr#zcf52q3aFPo+}9y?gi2-rkO(p`o}K2RzSvi<xuGY$qDm+G?P!t&Nyj*|u$E
zGMVh;<m74Fw%y~$k3&RYnkF)t3;@8gEV!<Vxw$!vjg7%|U09ZdFbrSweSa?zIjP=2
zExVy<nrvB?VOf?H1c9rRI&tdMDU6PeCbePtSu7S&EEch2#|~V+d>PD)TCK)m7@ko|
z-65i~h}5DsEv=N0iAafvp_Fp&-o5*ZQYv@u+_{!*wNxtM$dMyhSXe+lpNEJX5|M4u
z8G>6$F~zH|*Xue60xJlD%;MtW*v_3h(cRsh)aHghI5-H;^H8l;0f56WJRGazT6zJ8
zVW>RMGd<6<CnqOg)>=P5GBUCPxS7R~ipPn__CyhKqZ**-PZb1#>HEH2sZ_FEZoT;8
zK@V9+wFFLE6af&?6A?)_rxnMw7~BAm1JI?l9?WGkho-OQZpocNX?6x!qwfOH6&+Mo
zq(Y}oKGsk#I^TKSKe2staI~+dXN30tfpxH70rW-~oIWp7L?j1b^Y@?OW4YZea=TCD
zm%Zz;`lP!6tYj^4It_DkC<6w-MbPjath1@K7(Jtec^7)A95%!rH@g=I0P63<HiWZ)
zlsAgRiiVU72?MZyx{Zh4zkxjXYe8T60i_Kf@IkUYC&6`e>*)s21E2)p%MBo)lLX=v
zgi)iY0(clbpKMSH!n6pbBcUQU06g6Q0=yc5^evbY+Fe;^0xLBAKYIt$LJ+v54FCWD
M07*qoM6N<$f`?*(?f?J)

literal 0
HcmV?d00001

diff --git a/platform/3ds/memory.h b/platform/3ds/memory.h
new file mode 100644
index 0000000..3b2f590
--- /dev/null
+++ b/platform/3ds/memory.h
@@ -0,0 +1 @@
+#include <string.h>
diff --git a/platform/3ds/os_3ds.cpp b/platform/3ds/os_3ds.cpp
new file mode 100644
index 0000000..f45abd7
--- /dev/null
+++ b/platform/3ds/os_3ds.cpp
@@ -0,0 +1,357 @@
+/*************************************************************************/
+/*  os_3ds.cpp                                                           */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#include "servers/visual/visual_server_raster.h"
+#include "drivers/3ds/citro3d/rasterizer_citro3d.h"
+#include "os_3ds.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <time.h>
+#include <sys/time.h>
+#include "print_string.h"
+#include "servers/physics/physics_server_sw.h"
+#include "errno.h"
+
+#include "drivers/unix/memory_pool_static_malloc.h"
+#include "os/memory_pool_dynamic_static.h"
+// #include "thread_posix.h"
+// #include "semaphore_posix.h"
+// #include "mutex_posix.h"
+#include "core/os/thread_dummy.h"
+
+//#include "core/io/file_access_buffered_fa.h"
+#include "drivers/unix/file_access_unix.h"
+#include "drivers/unix/dir_access_unix.h"
+// #include "tcp_server_posix.h"
+// #include "stream_peer_tcp_posix.h"
+// #include "packet_peer_udp_posix.h"
+
+#include "main/main.h"
+
+extern "C" {
+#include <3ds/svc.h>
+#include <3ds/gfx.h>
+#include <3ds/console.h>
+#include <3ds/services/apt.h>
+#include <3ds/services/hid.h>
+// Big stack thanks to CANVAS_ITEM_Z_MAX among other things
+u32 __stacksize__ = 1024 * 128;
+}
+
+OS_3DS::OS_3DS()
+: video_mode(400, 240, true, false, true)
+{	
+	gfxInitDefault();
+	consoleInit(GFX_BOTTOM, NULL);
+// 	set_low_processor_usage_mode(true);
+// 	set_target_fps(60);
+	_render_thread_mode=RENDER_THREAD_UNSAFE;
+	AudioDriverManagerSW::add_driver(&audio_driver);
+}
+
+OS_3DS::~OS_3DS()
+{
+	gfxExit();
+}
+
+void OS_3DS::run()
+{
+	if (!main_loop)
+		return;
+	
+	main_loop->init();
+	
+	while (aptMainLoop())
+	{
+		hidScanInput();
+
+		u32 kDown = hidKeysDown();
+		if (kDown & KEY_START)
+			break; // break in order to return to hbmenu
+			
+		if (Main::iteration()==true)
+			break;
+
+		// Flush and swap framebuffers
+		gfxFlushBuffers();
+		gfxSwapBuffers();
+		gspWaitForVBlank();
+	}
+	
+	main_loop->finish();
+}
+
+static MemoryPoolStaticMalloc *mempool_static=NULL;
+static MemoryPoolDynamicStatic *mempool_dynamic=NULL;
+
+void OS_3DS::initialize_core()
+{
+	ThreadDummy::make_default();
+	SemaphoreDummy::make_default();
+	MutexDummy::make_default();
+	
+	FileAccess::make_default<FileAccessUnix>(FileAccess::ACCESS_RESOURCES);
+	FileAccess::make_default<FileAccessUnix>(FileAccess::ACCESS_USERDATA);
+	FileAccess::make_default<FileAccessUnix>(FileAccess::ACCESS_FILESYSTEM);
+	//FileAccessBufferedFA<FileAccessUnix>::make_default();
+	DirAccess::make_default<DirAccessUnix>(DirAccess::ACCESS_RESOURCES);
+	DirAccess::make_default<DirAccessUnix>(DirAccess::ACCESS_USERDATA);
+	DirAccess::make_default<DirAccessUnix>(DirAccess::ACCESS_FILESYSTEM);
+
+#ifndef NO_NETWORK
+// 	TCPServerPosix::make_default();
+// 	StreamPeerTCPPosix::make_default();
+// 	PacketPeerUDPPosix::make_default();
+// 	IP_Unix::make_default();
+#endif
+	mempool_static = new MemoryPoolStaticMalloc;
+	mempool_dynamic = memnew( MemoryPoolDynamicStatic );
+
+	ticks_start=svcGetSystemTick();
+}
+
+void OS_3DS::initialize(const VideoMode& p_desired,int p_video_driver,int p_audio_drive)
+{
+	main_loop=NULL;
+	
+	rasterizer = memnew( RasterizerCitro3d );
+	
+	visual_server = memnew( VisualServerRaster(rasterizer) );
+	
+	if (get_render_thread_mode()!=RENDER_THREAD_UNSAFE) {
+
+		visual_server =memnew(VisualServerWrapMT(visual_server,get_render_thread_mode()==RENDER_SEPARATE_THREAD));
+	}
+	
+	AudioDriverManagerSW::get_driver(0)->set_singleton();
+	if (AudioDriverManagerSW::get_driver(0)->init()!=OK)
+	{
+		ERR_PRINT("Initializing audio failed.");
+	}
+
+	sample_manager = memnew( SampleManagerMallocSW );
+	audio_server = memnew( AudioServerSW(sample_manager) );
+	audio_server->init();
+	spatial_sound_server = memnew( SpatialSoundServerSW );
+	spatial_sound_server->init();
+	spatial_sound_2d_server = memnew( SpatialSound2DServerSW );
+	spatial_sound_2d_server->init();
+
+	ERR_FAIL_COND(!visual_server);
+	
+	visual_server->init();
+	
+	physics_server = memnew( PhysicsServerSW );
+	physics_server->init();
+	physics_2d_server = memnew( Physics2DServerSW );
+// 	physics_2d_server = Physics2DServerWrapMT::init_server<Physics2DServerSW>();
+	physics_2d_server->init();
+
+	input = memnew( InputDefault );
+}
+
+void OS_3DS::delete_main_loop()
+{
+	if (main_loop)
+		memdelete(main_loop);
+	main_loop=NULL;
+}
+
+void OS_3DS::set_main_loop( MainLoop * p_main_loop )
+{
+	main_loop=p_main_loop;
+	input->set_main_loop(p_main_loop);
+}
+
+void OS_3DS::finalize()
+{
+	if(main_loop)
+		memdelete(main_loop);
+	main_loop=NULL;
+
+	spatial_sound_server->finish();
+	memdelete(spatial_sound_server);
+	spatial_sound_2d_server->finish();
+	memdelete(spatial_sound_2d_server);
+
+	memdelete(input);
+	
+	memdelete(sample_manager);
+
+	audio_server->finish();
+	memdelete(audio_server);
+
+	visual_server->finish();
+	memdelete(visual_server);
+	memdelete(rasterizer);
+
+	physics_server->finish();
+	memdelete(physics_server);
+
+	physics_2d_server->finish();
+	memdelete(physics_2d_server);
+}
+
+void OS_3DS::finalize_core()
+{
+	if (mempool_dynamic)
+		memdelete( mempool_dynamic );
+	delete mempool_static;
+}
+
+void OS_3DS::vprint(const char* p_format, va_list p_list,bool p_stder)
+{
+	if (p_stder) {
+		vfprintf(stderr,p_format,p_list);
+		fflush(stderr);
+	} else {
+		vprintf(p_format,p_list);
+		fflush(stdout);
+	}
+}
+
+void OS_3DS::alert(const String& p_alert,const String& p_title)
+{
+	fprintf(stderr,"ERROR: %s\n",p_alert.utf8().get_data());
+}
+
+Error OS_3DS::set_cwd(const String& p_cwd)
+{
+	printf("set cwd: %s", p_cwd.utf8().get_data());
+	if (chdir(p_cwd.utf8().get_data())!=0)
+		return ERR_CANT_OPEN;
+
+	return OK;
+}
+
+OS::Date OS_3DS::get_date(bool utc) const
+{
+
+	time_t t=time(NULL);
+	struct tm *lt;
+	if (utc)
+		lt=gmtime(&t);
+	else
+		lt=localtime(&t);
+	Date ret;
+	ret.year=1900+lt->tm_year;
+	// Index starting at 1 to match OS_Unix::get_date
+	//   and Windows SYSTEMTIME and tm_mon follows the typical structure 
+	//   of 0-11, noted here: http://www.cplusplus.com/reference/ctime/tm/
+	ret.month=(Month)(lt->tm_mon + 1);
+	ret.day=lt->tm_mday;
+	ret.weekday=(Weekday)lt->tm_wday;
+	ret.dst=lt->tm_isdst;
+	
+	return ret;
+}
+
+OS::Time OS_3DS::get_time(bool utc) const
+{
+	time_t t=time(NULL);
+	struct tm *lt;
+	if (utc)
+		lt=gmtime(&t);
+	else
+		lt=localtime(&t);
+	Time ret;
+	ret.hour=lt->tm_hour;
+	ret.min=lt->tm_min;
+	ret.sec=lt->tm_sec;
+	get_time_zone_info();
+	return ret;
+}
+
+OS::TimeZoneInfo OS_3DS::get_time_zone_info() const
+{
+	time_t t = time(NULL);
+	struct tm *lt = localtime(&t);
+	char name[16];
+	strftime(name, 16, "%Z", lt);
+	name[15] = 0;
+	TimeZoneInfo ret;
+	ret.name = name;
+
+	char bias_buf[16];
+	strftime(bias_buf, 16, "%z", lt);
+	int bias;
+	bias_buf[15] = 0;
+	sscanf(bias_buf, "%d", &bias);
+
+	// convert from ISO 8601 (1 minute=1, 1 hour=100) to minutes
+	int hour = (int)bias / 100;
+	int minutes = bias % 100;
+	if (bias < 0)
+		ret.bias = hour * 60 - minutes;
+	else
+		ret.bias = hour * 60 + minutes;
+
+	return ret;
+}
+
+void OS_3DS::delay_usec(uint32_t p_usec) const
+{
+	svcSleepThread(1000ULL * p_usec);
+}
+
+#define TICKS_PER_SEC 268123480ULL
+#define TICKS_PER_USEC 268
+
+uint64_t OS_3DS::get_ticks_usec() const
+{
+	return (svcGetSystemTick() - ticks_start) / TICKS_PER_USEC;
+}
+
+uint64_t OS_3DS::get_unix_time() const
+{
+	return time(NULL);
+}
+
+uint64_t OS_3DS::get_system_time_secs() const
+{
+	struct timeval tv_now;
+	gettimeofday(&tv_now, NULL);
+	//localtime(&tv_now.tv_usec);
+	//localtime((const long *)&tv_now.tv_usec);
+	return uint64_t(tv_now.tv_sec);
+}
+
+void OS_3DS::swap_buffers()
+{
+
+}
+
+int OS_3DS::get_processor_count() const
+{
+	return 1;
+}
+
+
+
+
diff --git a/platform/3ds/os_3ds.h b/platform/3ds/os_3ds.h
new file mode 100644
index 0000000..a8fb470
--- /dev/null
+++ b/platform/3ds/os_3ds.h
@@ -0,0 +1,305 @@
+/*************************************************************************/
+/*  os_x11.h                                                             */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+#ifndef OS_3DS_H
+#define OS_3DS_H
+
+
+#include "os/os.h"
+#include "os/input.h"
+#include "servers/visual_server.h"
+#include "servers/visual/visual_server_wrap_mt.h"
+#include "servers/visual/rasterizer.h"
+#include "servers/physics_server.h"
+#include "servers/audio/audio_driver_dummy.h"
+#include "servers/audio/audio_server_sw.h"
+#include "servers/audio/sample_manager_sw.h"
+#include "servers/spatial_sound/spatial_sound_server_sw.h"
+#include "servers/spatial_sound_2d/spatial_sound_2d_server_sw.h"
+#include "servers/physics_2d/physics_2d_server_sw.h"
+#include "servers/physics_2d/physics_2d_server_wrap_mt.h"
+#include "main/input_default.h"
+
+/**
+	@author Thomas Edvalson <machin3@gmail.com>
+*/
+
+class OS_3DS : public OS {
+	
+	MainLoop *main_loop;
+	Rasterizer *rasterizer;
+	VisualServer *visual_server;
+	InputDefault *input;
+	
+	PhysicsServer *physics_server;
+	Physics2DServer *physics_2d_server;
+	
+	AudioServerSW *audio_server;
+	SampleManagerMallocSW *sample_manager;
+	SpatialSoundServerSW *spatial_sound_server;
+	SpatialSound2DServerSW *spatial_sound_2d_server;
+	
+	AudioDriverDummy audio_driver;
+	
+	Point2i last_mouse_pos;
+	VideoMode video_mode;
+	
+	uint64_t ticks_start;
+
+protected:
+friend class Main;
+
+	// functions used by main to initialize/deintialize the OS
+	virtual int get_video_driver_count() const { return 1; }
+	virtual const char * get_video_driver_name(int p_driver) const { return "citro3d"; }
+
+	virtual VideoMode get_default_video_mode() const { return video_mode; }
+
+	virtual int get_audio_driver_count() const { return 1; }
+	virtual const char * get_audio_driver_name(int p_driver) const { return "ndsp"; }
+
+	virtual void initialize_core();
+	virtual void initialize(const VideoMode& p_desired,int p_video_driver,int p_audio_driver);
+
+	virtual void set_main_loop( MainLoop * p_main_loop );
+	virtual void delete_main_loop();
+
+	virtual void finalize();
+	virtual void finalize_core();
+
+// 	virtual void set_cmdline(const char* p_execpath, const List<String>& p_args);
+
+public:
+
+// 	virtual void print_error(const char* p_function,const char* p_file,int p_line,const char *p_code,const char*p_rationale,ErrorType p_type=ERR_ERROR);
+
+// 	virtual void print(const char *p_format, ... );
+// 	virtual void printerr(const char *p_format, ... );
+	virtual void vprint(const char* p_format, va_list p_list, bool p_stderr=false);
+	virtual void alert(const String& p_alert,const String& p_title="ALERT!");
+	virtual String get_stdin_string(bool p_block = true) { return ""; }
+
+// 	virtual void set_last_error(const char* p_error);
+// 	virtual const char *get_last_error() const;
+// 	virtual void clear_last_error();
+
+
+// 	virtual void set_mouse_mode(MouseMode p_mode);
+// 	virtual MouseMode get_mouse_mode() const;
+
+
+// 	virtual void warp_mouse_pos(const Point2& p_to)  {}
+	virtual Point2 get_mouse_pos() const { return last_mouse_pos; }
+	virtual int get_mouse_button_state() const { return 0; }
+	virtual void set_window_title(const String& p_title) {};
+
+// 	virtual void set_clipboard(const String& p_text) {}
+// 	virtual String get_clipboard() const { return ""; }
+
+	virtual void set_video_mode(const VideoMode& p_video_mode,int p_screen=0) {}
+	virtual VideoMode get_video_mode(int p_screen=0) const { return video_mode; }
+	virtual void get_fullscreen_mode_list(List<VideoMode> *p_list,int p_screen=0) const {}
+
+
+// 	virtual int get_screen_count() const{ return 1; }
+// 	virtual int get_current_screen() const { return 0; }
+// 	virtual void set_current_screen(int p_screen) { }
+// 	virtual Point2 get_screen_position(int p_screen=0) const { return Point2(); }
+// 	virtual Size2 get_screen_size(int p_screen=0) const { return get_window_size(); }
+// 	virtual int get_screen_dpi(int p_screen=0) const { return 72; }
+// 	virtual Point2 get_window_position() const { return Vector2(); }
+// 	virtual void set_window_position(const Point2& p_position) {}
+	virtual Size2 get_window_size() const { return Size2(400, 240); }
+// 	virtual void set_window_size(const Size2 p_size){}
+// 	virtual void set_window_fullscreen(bool p_enabled) {}
+// 	virtual bool is_window_fullscreen() const { return true; }
+// 	virtual void set_window_resizable(bool p_enabled) {}
+// 	virtual bool is_window_resizable() const { return false; }
+// 	virtual void set_window_minimized(bool p_enabled) {}
+// 	virtual bool is_window_minimized() const { return false; }
+// 	virtual void set_window_maximized(bool p_enabled) {}
+// 	virtual bool is_window_maximized() const { return true; }
+// 	virtual void request_attention() { }
+
+// 	virtual void set_borderless_window(int p_borderless) {}
+// 	virtual bool get_borderless_window() { return 0; }
+
+
+
+// 	virtual void set_iterations_per_second(int p_ips);
+// 	virtual int get_iterations_per_second() const;
+
+// 	virtual void set_target_fps(int p_fps);
+// 	virtual float get_target_fps() const;
+
+// 	virtual float get_frames_per_second() const { return _fps; }
+
+// 	virtual void set_keep_screen_on(bool p_enabled);
+// 	virtual bool is_keep_screen_on() const;
+// 	virtual void set_low_processor_usage_mode(bool p_enabled);
+// 	virtual bool is_in_low_processor_usage_mode() const;
+
+// 	virtual String get_installed_templates_path() const { return ""; }
+	virtual String get_executable_path() const {return "test"; }
+	virtual Error execute(const String& p_path, const List<String>& p_arguments,bool p_blocking,ProcessID *r_child_id=NULL,String* r_pipe=NULL,int *r_exitcode=NULL) { return FAILED; }
+	virtual Error kill(const ProcessID& p_pid) { return FAILED; }
+// 	virtual int get_process_ID() const;
+
+// 	virtual Error shell_open(String p_uri);
+	virtual Error set_cwd(const String& p_cwd);
+
+	virtual bool has_environment(const String& p_var) const { return false; }
+	virtual String get_environment(const String& p_var) const { return ""; }
+
+	virtual String get_name() { return "3DS"; }
+// 	virtual List<String> get_cmdline_args() const { return _cmdline; }
+// 	virtual String get_model_name() const;
+
+	virtual MainLoop *get_main_loop() const { return main_loop; }
+
+// 	String get_custom_level() const { return _custom_level; }
+
+// 	virtual void yield();
+
+
+	virtual Date get_date(bool local=false) const;
+	virtual Time get_time(bool local=false) const;
+	virtual TimeZoneInfo get_time_zone_info() const;
+	virtual uint64_t get_unix_time() const;
+	virtual uint64_t get_system_time_secs() const;
+
+	virtual void delay_usec(uint32_t p_usec) const;
+	virtual uint64_t get_ticks_usec() const;
+	uint32_t get_ticks_msec() const;
+	uint64_t get_splash_tick_msec() const;
+
+	void set_frame_delay(uint32_t p_msec);
+	uint32_t get_frame_delay() const;
+
+	virtual bool can_draw() const { return true; }
+
+// 	uint64_t get_frames_drawn();
+
+// 	uint64_t get_fixed_frames() const { return _fixed_frames; }
+// 	uint64_t get_idle_frames() const { return _idle_frames; }
+// 	bool is_in_fixed_frame() const { return _in_fixed; }
+
+	bool is_stdout_verbose() const;
+
+
+// 	virtual bool has_virtual_keyboard() const;
+// 	virtual void show_virtual_keyboard(const String& p_existing_text,const Rect2& p_screen_rect=Rect2());
+// 	virtual void hide_virtual_keyboard();
+
+	virtual void set_cursor_shape(CursorShape p_shape) {}
+
+	virtual bool get_swap_ok_cancel() { return false; }
+// 	virtual void dump_memory_to_file(const char* p_file);
+// 	virtual void dump_resources_to_file(const char* p_file);
+// 	virtual void print_resources_in_use(bool p_short=false);
+// 	virtual void print_all_resources(String p_to_file="");
+
+// 	virtual int get_static_memory_usage() const;
+// 	virtual int get_static_memory_peak_usage() const;
+// 	virtual int get_dynamic_memory_usage() const;
+// 	virtual int get_free_static_memory() const;
+
+// 	RenderThreadMode get_render_thread_mode() const { return RENDER_THREAD_UNSAFE; }
+
+// 	virtual String get_locale() const;
+
+// 	String get_safe_application_name() const;
+// 	virtual String get_data_dir() const { return "."; }
+// 	virtual String get_resource_dir() const { printf("res dir: %s\n", Globals::get_singleton()->get_resource_path().utf8().get_data()); return Globals::get_singleton()->get_resource_path(); }
+
+
+// 	virtual String get_system_dir(SystemDir p_dir) const;
+
+
+// 	virtual void set_no_window_mode(bool p_enable);
+// 	virtual bool is_no_window_mode_enabled() const;
+
+// 	virtual bool has_touchscreen_ui_hint() const;
+
+
+// 	virtual void set_screen_orientation(ScreenOrientation p_orientation);
+// 	ScreenOrientation get_screen_orientation() const;
+
+// 	virtual void move_window_to_foreground() {}
+
+// 	virtual void debug_break();
+
+// 	virtual void release_rendering_thread();
+// 	virtual void make_rendering_thread();
+	virtual void swap_buffers();
+
+
+// 	virtual void set_icon(const Image& p_icon);
+
+// 	virtual int get_exit_code() const;
+// 	virtual void set_exit_code(int p_code);
+
+	virtual int get_processor_count() const;
+
+// 	virtual String get_unique_ID() const;
+
+// 	virtual Error native_video_play(String p_path, float p_volume, String p_audio_track, String p_subtitle_track);
+// 	virtual bool native_video_is_playing() const;
+// 	virtual void native_video_pause();
+// 	virtual void native_video_unpause();
+// 	virtual void native_video_stop();
+
+	virtual bool can_use_threads() const { return false; }
+
+// 	virtual Error dialog_show(String p_title, String p_description, Vector<String> p_buttons, Object* p_obj, String p_callback);
+// 	virtual Error dialog_input_text(String p_title, String p_description, String p_partial, Object* p_obj, String p_callback);
+
+
+// 	virtual LatinKeyboardVariant get_latin_keyboard_variant() const;
+
+// 	void set_time_scale(float p_scale);
+// 	float get_time_scale() const;
+
+
+// 	virtual bool is_joy_known(int p_device);
+// 	virtual String get_joy_guid(int p_device)const;
+
+// 	virtual void set_context(int p_context);
+
+// 	virtual void set_use_vsync(bool p_enable);
+	virtual bool is_vsnc_enabled() const { return true; }
+
+// 	Dictionary get_engine_version() const;
+
+	void run();
+
+	OS_3DS();
+	virtual ~OS_3DS();
+};
+
+#endif
diff --git a/platform/3ds/platform_config.h b/platform/3ds/platform_config.h
new file mode 100644
index 0000000..acb4f02
--- /dev/null
+++ b/platform/3ds/platform_config.h
@@ -0,0 +1,39 @@
+/*************************************************************************/
+/*  platform_config.h                                                    */
+/*************************************************************************/
+/*                       This file is part of:                           */
+/*                           GODOT ENGINE                                */
+/*                    http://www.godotengine.org                         */
+/*************************************************************************/
+/* Copyright (c) 2007-2016 Juan Linietsky, Ariel Manzur.                 */
+/*                                                                       */
+/* Permission is hereby granted, free of charge, to any person obtaining */
+/* a copy of this software and associated documentation files (the       */
+/* "Software"), to deal in the Software without restriction, including   */
+/* without limitation the rights to use, copy, modify, merge, publish,   */
+/* distribute, sublicense, and/or sell copies of the Software, and to    */
+/* permit persons to whom the Software is furnished to do so, subject to */
+/* the following conditions:                                             */
+/*                                                                       */
+/* The above copyright notice and this permission notice shall be        */
+/* included in all copies or substantial portions of the Software.       */
+/*                                                                       */
+/* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,       */
+/* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF    */
+/* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.*/
+/* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  */
+/* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  */
+/* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE     */
+/* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.                */
+/*************************************************************************/
+// #ifdef __linux__
+// #include <alloca.h>
+// #endif
+// #if defined(__FreeBSD__) || defined(__OpenBSD__)
+#include <stdlib.h>
+// #define PTHREAD_BSD_SET_NAME
+// #endif
+// 
+// #define GLES2_INCLUDE_H "gl_context/GL/glew.h"
+
+
-- 
2.7.3


From 73857da23c8c4f6bb9095b1cc80baa906c269e92 Mon Sep 17 00:00:00 2001
From: Thomas Edvalson <machin3@gmail.com>
Date: Fri, 7 Oct 2016 03:42:30 -0400
Subject: [PATCH 2/4] Removing trailing slash from current work directory

---
 drivers/unix/dir_access_unix.cpp | 9 +++++++++
 1 file changed, 9 insertions(+)

diff --git a/drivers/unix/dir_access_unix.cpp b/drivers/unix/dir_access_unix.cpp
index b3bea8a..8f15c5f 100644
--- a/drivers/unix/dir_access_unix.cpp
+++ b/drivers/unix/dir_access_unix.cpp
@@ -38,6 +38,9 @@
 #include "os/memory.h"
 #include "print_string.h"
 #include <errno.h>
+#ifdef _3DS
+#include <string.h>
+#endif
 
 DirAccess *DirAccessUnix::create_fs() {
 
@@ -242,6 +245,7 @@ Error DirAccessUnix::change_dir(String p_dir) {
 
 	char real_current_dir_name[2048];
 	getcwd(real_current_dir_name,2048);
+
 	String prev_dir;
 	if (prev_dir.parse_utf8(real_current_dir_name))
 		prev_dir=real_current_dir_name; //no utf8, maybe latin?
@@ -262,6 +266,11 @@ Error DirAccessUnix::change_dir(String p_dir) {
 	if (worked) {
 
 		getcwd(real_current_dir_name,2048);
+#ifdef _3DS
+		int l = strlen(real_current_dir_name) - 1;
+		if (real_current_dir_name[l] == '/')
+			real_current_dir_name[l] = '\0';
+#endif
 		if (current_dir.parse_utf8(real_current_dir_name))
 			current_dir=real_current_dir_name; //no utf8, maybe latin?
 	}
-- 
2.7.3


From d76be89b96e7a8a69e0394cd6e532a45fb201cb9 Mon Sep 17 00:00:00 2001
From: Thomas Edvalson <machin3@gmail.com>
Date: Fri, 7 Oct 2016 03:49:07 -0400
Subject: [PATCH 3/4] Disable tools build in travis

---
 .build.sh | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/.build.sh b/.build.sh
index dcc8c9f..2dddb44 100644
--- a/.build.sh
+++ b/.build.sh
@@ -10,4 +10,4 @@ if [ "$1" = "x11" ] ; then
 	apt-get -y install libxcursor-dev libasound2-dev libssl-dev libxinerama-dev libxrandr-dev
 fi
 
-scons platform=$1 target=release -j 4
+scons platform=$1 target=release tools=no -j 4
-- 
2.7.3


From 2030306a9d9d521f1b0050fafd58b8bf3d932a91 Mon Sep 17 00:00:00 2001
From: Thomas Edvalson <machin3@gmail.com>
Date: Wed, 12 Oct 2016 03:37:42 -0400
Subject: [PATCH 4/4] Add shader compiler to SCons

---
 drivers/3ds/citro3d/SCsub           |  4 +--
 drivers/3ds/citro3d/shaders/2d.pica | 48 +++++++++++++++++++++++++
 drivers/3ds/citro3d/shaders/3d.pica | 71 +++++++++++++++++++++++++++++++++++++
 drivers/3ds/citro3d/shaders/SCsub   | 11 ++++++
 platform/3ds/detect.py              | 55 ++++++++++++++--------------
 5 files changed, 158 insertions(+), 31 deletions(-)
 create mode 100644 drivers/3ds/citro3d/shaders/2d.pica
 create mode 100644 drivers/3ds/citro3d/shaders/3d.pica
 create mode 100644 drivers/3ds/citro3d/shaders/SCsub

diff --git a/drivers/3ds/citro3d/SCsub b/drivers/3ds/citro3d/SCsub
index 1ffb312..931c8ba 100644
--- a/drivers/3ds/citro3d/SCsub
+++ b/drivers/3ds/citro3d/SCsub
@@ -1,5 +1,5 @@
 Import('env')
 
-env.add_source_files(env.drivers_sources,"*.cpp")
+SConscript("shaders/SCsub")
 
-#SConscript("shaders/SCsub")
+env.add_source_files(env.drivers_sources,"*.cpp")
diff --git a/drivers/3ds/citro3d/shaders/2d.pica b/drivers/3ds/citro3d/shaders/2d.pica
new file mode 100644
index 0000000..c9d1c60
--- /dev/null
+++ b/drivers/3ds/citro3d/shaders/2d.pica
@@ -0,0 +1,48 @@
+; Uniforms
+.fvec projection[4], modelView[4], extra[4]
+
+; Constants
+.constf myconst(0.0, 1.0, -1.0, -0.5)
+;.constf myconst2(0.3, 0.0, 0.0, 0.0)
+.alias  zeros myconst.xxxx ; Vector full of zeros
+.alias  ones  myconst.yyyy ; Vector full of ones
+
+; Outputs
+.out outpos position
+.out outtc0 texcoord0
+.out outclr color
+
+; Inputs (defined as aliases for convenience)
+.alias inpos v0
+.alias intex v1
+.alias incol v2
+
+.proc main
+	; Force the w component of inpos to be 1.0
+	mov r0.xyz, inpos
+	mov r0.w,   ones
+	
+	; r1 = extra * inpos
+	dp4 r1.x, extra[0], r0
+	dp4 r1.y, extra[1], r0
+	dp4 r1.z, extra[2], r0
+	dp4 r1.w, extra[3], r0
+	
+	; r2 = modelView * r1
+	dp4 r2.x, modelView[0], r1
+	dp4 r2.y, modelView[1], r1
+	dp4 r2.z, modelView[2], r1
+	dp4 r2.w, modelView[3], r1
+
+	; outpos = projection * r2
+	dp4 outpos.x, projection[0], r2
+	dp4 outpos.y, projection[1], r2
+	dp4 outpos.z, projection[2], r2
+	dp4 outpos.w, projection[3], r2
+
+ 	mov outtc0, intex
+ 	
+ 	mov outclr, incol
+
+	end
+.end
diff --git a/drivers/3ds/citro3d/shaders/3d.pica b/drivers/3ds/citro3d/shaders/3d.pica
new file mode 100644
index 0000000..754c40c
--- /dev/null
+++ b/drivers/3ds/citro3d/shaders/3d.pica
@@ -0,0 +1,71 @@
+; Uniforms
+.fvec projection[4], modelView[4]
+
+; Constants
+.constf myconst(0.0, 1.0, -1.0, 0.5)
+.alias  zeros myconst.xxxx ; Vector full of zeros
+.alias  ones  myconst.yyyy ; Vector full of ones
+.alias  half  myconst.wwww
+
+; Outputs
+.out outpos position
+.out outtc0 texcoord0
+.out outclr color
+.out outview view
+.out outnq normalquat
+
+; Inputs (defined as aliases for convenience)
+.alias inpos v0
+.alias intex v1
+.alias innrm v2
+
+.proc main
+	; Force the w component of inpos to be 1.0
+	mov r0.xyz, inpos
+	mov r0.w,   ones
+
+	; r1 = modelView * inpos
+	dp4 r1.x, modelView[0], r0
+	dp4 r1.y, modelView[1], r0
+	dp4 r1.z, modelView[2], r0
+	dp4 r1.w, modelView[3], r0
+
+	; outview = -r1
+	mov outview, -r1
+
+	; outpos = projection * r1
+	dp4 outpos.x, projection[0], r1
+	dp4 outpos.y, projection[1], r1
+	dp4 outpos.z, projection[2], r1
+	dp4 outpos.w, projection[3], r1
+
+	; outtex = intex
+	mov outtc0, intex
+
+	; Transform the normal vector with the modelView matrix
+	; TODO: use a separate normal matrix that is the transpose of the inverse of modelView
+	dp3 r14.x, modelView[0], innrm
+	dp3 r14.y, modelView[1], innrm
+	dp3 r14.z, modelView[2], innrm
+	dp3 r6.x, r14, r14
+	rsq r6.x, r6.x
+	mul r14.xyz, r14.xyz, r6.x
+
+	mov r0, myconst.yxxx
+	add r4, ones, r14.z
+	mul r4, half, r4
+	cmp zeros, ge, ge, r4.x
+	rsq r4, r4.x
+	mul r5, half, r14
+	jmpc cmp.x, degenerate
+
+	rcp r0.z, r4.x
+	mul r0.xy, r5, r4
+
+degenerate:
+	mov outnq, r0
+	mov outclr, ones
+
+	; We're finished
+	end
+.end
diff --git a/drivers/3ds/citro3d/shaders/SCsub b/drivers/3ds/citro3d/shaders/SCsub
new file mode 100644
index 0000000..9610658
--- /dev/null
+++ b/drivers/3ds/citro3d/shaders/SCsub
@@ -0,0 +1,11 @@
+Import('env')
+
+shaders = [
+	'2d',
+	'3d',
+]
+
+if env['BUILDERS'].has_key('PICA'):
+	for shader in shaders:
+		env.PICA(shader)
+		env.PICA_HEADER(shader)
diff --git a/platform/3ds/detect.py b/platform/3ds/detect.py
index 205c69b..292fcb5 100644
--- a/platform/3ds/detect.py
+++ b/platform/3ds/detect.py
@@ -15,6 +15,8 @@ def can_build():
 
 	if (not os.environ.has_key("DEVKITPRO")):
 		return False
+	if (not os.environ.has_key("DEVKITARM")):
+		return False
 	if (not os.environ.has_key("CTRULIB")):
 		return False
 	if (os.name=="nt"):
@@ -44,16 +46,38 @@ def get_opts():
 def get_flags():
 
 	return [
-	('builtin_zlib', 'no'),
 	('tools', 'no'),
+	('squish', 'no'),
+	('theora', 'no'),
+	('speex', 'no'),
+	('dds', 'no'),
+	('pvr', 'no'),
+	('etc1', 'no'),
+	('builtin_zlib', 'no'),
 	("openssl", "no"),
-	('freetype','builtin'),
+	('musepack', 'no'),
 	]
 
+def build_shader_gen(target, source, env, for_signature):
+	return "picasso -o {} {}".format(target[0], source[0])
 
+def build_shader_header(target, source, env):
+	import os
+	data = source[0].get_contents()
+	data_str = ",".join([str(ord(x)) for x in data])
+	name = os.path.basename(str(target[0]))[:-2]
+	target[0].prepare()
+	with open(str(target[0]), 'w') as f:
+		f.write("/* Auto-generated from {} */\n".format(str(source[0])))
+		f.write("static uint8_t shader_builtin_{}[] =\n{{{}}};".format(name, data_str))
 
 def configure(env):
 	
+	env.disabled_modules = ['enet']
+
+	env.Append( BUILDERS = { 'PICA' : env.Builder(generator = build_shader_gen, suffix = '.shbin', src_suffix = '.pica') } )
+	env.Append( BUILDERS = { 'PICA_HEADER' : env.Builder(action = build_shader_header, suffix = '.h', src_suffix = '.shbin') } )
+	
 	env["bits"]="32"
 
 	env.Append(CPPPATH=['#platform/3ds'])
@@ -159,30 +183,3 @@ def configure(env):
 	#if (platform.system() == "Linux"):
 		#env.Append(LIBS='dl')
 	#env.Append(CPPFLAGS=['-DMPC_FIXED_POINT'])
-
-#host compiler is default..
-
-	#if (is64 and env["bits"]=="32"):
-		#env.Append(CPPFLAGS=['-m32'])
-		#env.Append(LINKFLAGS=['-m32','-L/usr/lib/i386-linux-gnu'])
-	#elif (not is64 and env["bits"]=="64"):
-		#env.Append(CPPFLAGS=['-m64'])
-		#env.Append(LINKFLAGS=['-m64','-L/usr/lib/i686-linux-gnu'])
-
-
-	import methods
-	
-	env.disabled_modules = ['enet']
-
-	#env.Append( BUILDERS = { 'GLSL120' : env.Builder(action = methods.build_legacygl_headers, suffix = 'glsl.h',src_suffix = '.glsl') } )
-	#env.Append( BUILDERS = { 'GLSL' : env.Builder(action = methods.build_glsl_headers, suffix = 'glsl.h',src_suffix = '.glsl') } )
-	#env.Append( BUILDERS = { 'GLSL120GLES' : env.Builder(action = methods.build_gles2_headers, suffix = 'glsl.h',src_suffix = '.glsl') } )
-	#env.Append( BUILDERS = { 'HLSL9' : env.Builder(action = methods.build_hlsl_dx9_headers, suffix = 'hlsl.h',src_suffix = '.hlsl') } )
-
-	#if (env["use_static_cpp"]=="yes"):
-		#env.Append(LINKFLAGS=['-static-libstdc++'])
-
-	#list_of_x86 = ['x86_64', 'x86', 'i386', 'i586']
-	#if any(platform.machine() in s for s in list_of_x86):
-		#env["x86_opt_gcc"]=True
-
-- 
2.7.3

